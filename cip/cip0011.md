---
id: "0011"
title: "Simplify VibeSafe Component Management: Requirements, Tenets, and Summary Tools"
status: "In Progress"
created: "2026-01-03"
last_updated: "2026-01-03"
author: "Neil Lawrence"
related_requirements: ["0001", "0002", "0003", "0004", "0005", "0006", "0007", "0008"]
---

# CIP-0011: Simplify VibeSafe Component Management

## Status
- [x] Proposed
- [x] Accepted (2026-01-03 - Phase 0a, 0b, 0c complete)
- [x] In Progress (2026-01-03 - Actively implementing)
- [ ] Implemented
- [ ] Closed

## Description

This CIP addresses HOW to achieve the outcomes defined in requirements 0001 through 0008:
- **0001**: Standardized metadata across components
- **0002**: Simple, easy-to-understand requirements framework
- **0003**: Accessible guidance without prescriptive structure
- **0004**: Sustainable tenets that remain relevant
- **0005**: Clear understanding of project status
- **0006**: Automated process conformance validation
- **0007**: Automatic system updates on installation
- **0008**: Clear boundaries between framework and user content

### Current Problems (Motivating the Requirements)

1. **Lack of Standardization**: Different components use different metadata structures
2. **Requirements Too Complex**: ai-requirements framework has 6 subdirectories and overlapping concepts
3. **Patterns Misplaced**: Teaching materials presented as user project structure
4. **Tenets Drift**: No process to keep tenets aligned with project reality
5. **Fragmented Status**: No single view of project state across all components

## Motivation

### Current Problems

**1. Requirements Are Too Complex**
- The ai-requirements directory has 6 subdirectories and multiple layers
- Users don't know where to put actual requirements
- The framework is more complex than the problems it solves
- Overlap with backlog and CIPs creates confusion

**2. Tenets Lack Sustainability**
- No process for reviewing/updating tenets as projects evolve
- No way to identify stale or conflicting tenets
- No tool to summarize current tenets for quick reference
- Tenets can drift from actual project practices

**3. Summary Tools Are Fragmented**
- `whats-next` only covers backlog/CIPs/git status
- No easy way to see requirements status
- No way to review tenets without reading all files
- Components feel disconnected

### Why This Matters

VibeSafe's value proposition is *simplicity* and *ease of use*. Complex systems that require extensive learning undermine this. We need:
- Clear, simple patterns for each component
- Integration where it makes sense
- Tools that provide quick understanding
- Sustainability processes that prevent drift

## Proposed Solution

### 0. Establish Consistent YAML Frontmatter Across All Components

**All VibeSafe components should use YAML frontmatter for metadata:**

**Common Fields Across All Types:**
```yaml
id: "unique-identifier"
title: "Human-readable title"
status: "Current status"
created: "YYYY-MM-DD"
last_updated: "YYYY-MM-DD"
tags:
  - tag1
  - tag2
```

**Component-Specific Extensions:**

| Component | Additional Fields |
|-----------|------------------|
| **Requirement** | `priority`, `stakeholders`, `related_tenets`, `related_cips`, `related_backlog` |
| **CIP** | `author`, `related_requirements`, `related_cips`, `blocked_by`, `superseded_by` |
| **Backlog Task** | `priority`, `category`, `owner`, `dependencies`, `related_cips` |
| **Tenet** | `last_reviewed`, `review_frequency`, `conflicts_with` |

**File Naming Conventions (implements REQ-0008 - clear boundaries):**

| Component | File Pattern | ID Pattern | Example File | Example ID |
|-----------|--------------|------------|--------------|------------|
| **Requirement** | `reqXXXX_short-name.md` | `"XXXX"` | `req0001_yaml-standardization.md` | `"0001"` |
| **CIP** | `cipXXXX_short-name.md` | `"XXXX"` | `cip0011_component-management.md` | `"0011"` |
| **Backlog** | `YYYY-MM-DD_short-name.md` | `"YYYY-MM-DD_short-name"` | `2026-01-03_yaml-frontmatter.md` | `"2026-01-03_yaml-frontmatter"` |
| **Tenet** | `short-name.md` | `"short-name"` | `simplicity-of-use.md` | `"simplicity-of-use"` |

**Notes:**
- **Requirement**: 4-digit hexadecimal (0001-FFFF), short name required
- **CIP**: 4-digit hexadecimal (0001-FFFF), short name optional for backwards compatability.
- **Backlog**: Date-based (YYYY-MM-DD) for chronological ordering, short name required
- **Tenet**: Descriptive kebab-case name
- All filenames lowercase, IDs are just the numbers (no prefix in YAML)

**Clear Boundaries (REQ-0008):**
- Consistent naming helps users identify component types at a glance
- No ambiguity between requirement/CIP/backlog/tenet files
- User can easily distinguish their components from framework examples

**Linking Philosophy** (Bottom-up):
- **Requirements** reference tenets (WHY informs WHAT)
- **CIPs** reference requirements (WHAT informs HOW)
- **Backlog** references CIPs (HOW informs DO)
- Scripts derive inverse: "Which requirements relate to this tenet?" by querying requirements

This enables:
- Automated parsing and analysis
- Bidirectional traversal (query in either direction)
- Status tracking and reporting
- Easy filtering and querying
- Traceability: Tenet ‚Üí Requirements ‚Üí CIPs ‚Üí Backlog

### 1. Simplify Requirements System

**Replace Complex Framework with Simple Integration:**

```
Current Structure (COMPLEX):
ai-requirements/
‚îú‚îÄ‚îÄ README.md (framework documentation)
‚îú‚îÄ‚îÄ requirement_template.md
‚îú‚îÄ‚îÄ prompts/ (discovery, refinement, validation, testing)
‚îú‚îÄ‚îÄ patterns/ (stakeholder-identification, goal-decomposition)
‚îú‚îÄ‚îÄ integrations/ (backlog, cip, common)
‚îú‚îÄ‚îÄ examples/ (4 examples)
‚îú‚îÄ‚îÄ guidance/ (conversation tips)
‚îî‚îÄ‚îÄ [Actual requirement files scattered around]

Proposed Structure (SIMPLE):
requirements/
‚îú‚îÄ‚îÄ README.md (simple usage guide)
‚îú‚îÄ‚îÄ req0001_yaml-standardization.md
‚îú‚îÄ‚îÄ req0002_simplify-requirements-framework.md
‚îî‚îÄ‚îÄ archive/ (completed/rejected requirements)
```

**Simple Requirements Format:**

```markdown
---
id: "0001"
title: "Standardized Component Metadata"
status: "Ready"
priority: "High"
created: "2026-01-03"
related_tenets: ["simplicity-of-use"]
related_cips: ["0011"]
related_backlog: []
---

# Requirement 0001: Standardized Component Metadata

## Description
Brief description of what's needed (2-3 paragraphs max)

## Acceptance Criteria
- [ ] Users can log in with email/password
- [ ] Sessions persist for 24 hours
- [ ] Logout clears all session data

## User Stories (Optional)
As a user, I want to log in so that I can access my data.

## Notes (Optional)
Any additional context, constraints, or considerations
```

**Decision Rules:**
- **Simple requirement** ‚Üí Create a requirement file in `requirements/`
- **Requirement needs design** ‚Üí Create a CIP (CIPs are just detailed requirements with implementation plans)
- **Requirement ready to implement** ‚Üí Create a backlog task
- **Completed requirement** ‚Üí Move to `requirements/archive/`

### 2. Add Tenets Sustainability Process

**Tenet Lifecycle:**

```
Created ‚Üí Active ‚Üí Under Review ‚Üí Updated/Archived
```

**New Tenet Format with YAML Frontmatter:**

```markdown
---
id: "simplicity-of-use"
title: "Simplicity at All Levels"
status: "Active"
created: "2025-05-05"
last_reviewed: "2026-01-03"
review_frequency: "Annual"
related_cips: ["000E", "0011"]
tags:
  - core-principle
  - usability
---

# Project Tenet: Simplicity at All Levels

## Description
[1-2 paragraphs explaining the principle, its importance, and how it guides decisions]

## Quote
*"[Memorable phrase that captures the essence of the tenet]"*

## Examples
- [Concrete example of applying this tenet]
- [Another example in a different context]

## Counter-examples
- [Example of violating this tenet]
- [Another example of what not to do]

## Conflicts
- [Potential conflict with another tenet]
- Resolution: [How to resolve the conflict]

## Recent Violations (Optional)
Track when we've deviated and learned:
- 2026-01-03: [Brief description and lesson learned]
```

**Review Process:**
1. **Quarterly Tenet Review**: Check if tenets still align with project reality
2. **Track Violations**: When we violate a tenet, document why (maybe tenet needs updating)
3. **Conflict Detection**: Identify when tenets conflict with each other
4. **Usage Tracking**: Which tenets are referenced in CIPs/decisions?

### 3. Create Unified Summary Tool

**New Script: `scripts/project_summary.py`**

Extends `whats-next` with comprehensive project understanding:

```bash
./project-summary                    # Full summary
./project-summary --requirements     # Only requirements
./project-summary --tenets           # Only tenets
./project-summary --status           # Quick status across all components
```

**Output Example:**

```
VibeSafe Project Summary
========================

üìã Requirements Status
- 12 requirements total
- 3 Proposed (need refinement)
- 5 Ready (can start implementation)  
- 4 In Progress (being implemented)
- Oldest unaddressed: REQ-005 (45 days)

üéØ Tenets Status
- 6 active tenets
- 2 need review (>6 months old)
- 1 potential conflict detected (Simplicity vs User Autonomy in CIP-0003)

üìä CIPs and Backlog
[Existing whats-next output]

üí° Recommended Next Actions
1. Review REQ-003 (highest priority, no implementation plan)
2. Update "Simplicity" tenet (conflict detected)
3. Complete CIP-0005 (blocking 3 requirements)
```

### 4. Patterns: VibeSafe Guidance vs User Content

**Critical Distinction: VibeSafe Framework vs User Projects**

Patterns are **VibeSafe's pedagogical content** - they teach users HOW to think about requirements. They should NOT be forced into user project structures.

**VibeSafe Level (Framework - Part of VibeSafe Repo):**
```
docs/patterns/              # VibeSafe's teaching/guidance
‚îú‚îÄ‚îÄ README.md               # "How to think about requirements"
‚îú‚îÄ‚îÄ stakeholder-analysis.md # Thinking tool (VibeSafe guidance)
‚îú‚îÄ‚îÄ goal-decomposition.md   # Thinking tool (VibeSafe guidance)
‚îú‚îÄ‚îÄ constraint-mapping.md   # Thinking tool (VibeSafe guidance)
‚îî‚îÄ‚îÄ examples/
    ‚îú‚îÄ‚îÄ user-persona-example.md
    ‚îî‚îÄ‚îÄ user-journey-example.md
```

These are like a textbook's "how to approach problems" - they're reference material, not project structure.

**User Project Level (Actual Work - In User Repos):**
```
requirements/
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ functional/             # Optional categorization
‚îÇ   ‚îú‚îÄ‚îÄ REQ-001_user-auth.md
‚îÇ   ‚îî‚îÄ‚îÄ REQ-002_data-export.md
‚îú‚îÄ‚îÄ non-functional/         # Optional categorization
‚îÇ   ‚îú‚îÄ‚îÄ REQ-010_performance.md
‚îÇ   ‚îî‚îÄ‚îÄ REQ-011_security.md
‚îî‚îÄ‚îÄ user-research/          # Optional - if project needs it
    ‚îú‚îÄ‚îÄ persona-admin.md
    ‚îî‚îÄ‚îÄ persona-end-user.md
```

**How Patterns Work:**

1. **VibeSafe provides guidance** in `docs/patterns/`:
   - "Here's how to think about stakeholder analysis"
   - "Here's how to decompose goals"
   - These live in VibeSafe repo, not user repos

2. **Users apply that guidance** in their `requirements/`:
   - Create their actual requirements
   - Optionally categorize by type (functional, non-functional, etc.)
   - Optionally include user research if project needs it

3. **Cursor rules reference patterns**:
   - "Struggling with requirements? See docs/patterns/goal-decomposition.md"
   - Patterns are linked as helpful resources, not mandatory structure

**Requirements Categorization (Optional):**

Users can optionally categorize requirements by:
- **Type**: functional, non-functional, user-facing, technical
- **Priority**: high, medium, low
- **Status**: proposed, ready, in-progress, implemented
- **Stakeholder**: customer-facing, internal, compliance

But categorization is OPTIONAL - simple projects can just have flat `requirements/` directory.

**Example User Project:**

```
# Simple project (no categorization needed)
requirements/
‚îú‚îÄ‚îÄ REQ-001_user-login.md
‚îú‚îÄ‚îÄ REQ-002_data-export.md
‚îî‚îÄ‚îÄ REQ-003_email-notifications.md

# Complex project (uses categorization)
requirements/
‚îú‚îÄ‚îÄ functional/
‚îÇ   ‚îú‚îÄ‚îÄ REQ-001_user-login.md
‚îÇ   ‚îî‚îÄ‚îÄ REQ-002_data-export.md
‚îú‚îÄ‚îÄ non-functional/
‚îÇ   ‚îú‚îÄ‚îÄ REQ-010_response-time.md
‚îÇ   ‚îî‚îÄ‚îÄ REQ-011_data-encryption.md
‚îî‚îÄ‚îÄ user-research/
    ‚îú‚îÄ‚îÄ persona-admin.md
    ‚îî‚îÄ‚îÄ journey-onboarding.md
```

### 5. Integration Philosophy

**Clear Boundaries:**

| Component | Level | Purpose | When to Use | Links To |
|-----------|-------|---------|-------------|----------|
| **Tenets** | User Project | **WHY** we make decisions | Guiding principles | (none - foundation) |
| **Requirements** | User Project | **WHAT** needs to be built | Starting new features | ‚Üí Tenets |
| **CIPs** | User Project | **HOW** it will be built | Complex features | ‚Üí Requirements |
| **Backlog** | User Project | **DOING** the work | Ready-to-implement | ‚Üí CIPs |
| **Patterns** | VibeSafe (Guidance) | HOW to think | Learning, stuck | (reference only) |

**Key Insight:** Patterns are VibeSafe's teaching materials, not user project structure.

**Linking Pattern (Bottom-Up):**
```
Tenets (WHY - foundation)
    ‚Üë
Requirements (WHAT) ‚îÄ‚îÄ‚Üí related_tenets
    ‚Üë
CIPs (HOW) ‚îÄ‚îÄ‚Üí related_requirements
    ‚Üë
Backlog (DO) ‚îÄ‚îÄ‚Üí related_cips
    ‚Üì
Implementation

Scripts query DOWN to find dependencies:
- "Which requirements inform this tenet?" ‚Üí Query requirements.related_tenets
- "Which CIPs implement this requirement?" ‚Üí Query cips.related_requirements
- "Which tasks execute this CIP?" ‚Üí Query backlog.related_cips
```

**Why Bottom-Up Linking?**
- Each component references its immediate context (one level up)
- Scripts derive inverse relationships by querying
- Keeps YAML simple (don't list everything below you)
- Natural: "What am I based on?" not "What depends on me?"

### 6. WHAT vs HOW Distinction - Integration Across VibeSafe

**Fundamental Principle**: Requirements describe **WHAT** should be true (outcomes). CIPs describe **HOW** to achieve it (design). Backlog describes **DOING** the work (execution).

This distinction must be reinforced throughout VibeSafe to prevent confusion between outcomes and implementation.

**Integration Points:**

#### 6.1 Templates
- **CIP Template**: Add `related_requirements` field, note "This CIP describes HOW to achieve requirements"
- **Backlog Template**: Add note "This task is DOING work defined in requirements/CIPs"
- **Requirements Template**: Add note "Requirements describe WHAT should be true (outcomes, not implementation)"

#### 6.2 Documentation
- **requirements/README.md**: Dedicated section on WHAT vs HOW with examples
- **Main README**: Visual flow diagram showing WHAT ‚Üí HOW ‚Üí DO
- **CIP README**: Explain CIPs implement requirements
- **Backlog README**: Explain tasks execute CIPs

#### 6.3 Cursor Rules
- **requirements_rule.mdc**: 
  - Add decision guide: "Am I describing WHAT (requirement) or HOW (CIP)?"
  - Examples of good requirements (outcome-focused) vs bad (implementation details)
- **cip.mdc**: Add note about CIPs addressing specific requirements
- **vibesafe_general.mdc**: Add to development practices

#### 6.4 Examples (Dogfooding)
Use VibeSafe's own components as examples showing the linking pattern:

**Tenet** (WHY):
```yaml
id: "simplicity-of-use"
title: "Simplicity at All Levels"
```

**Requirement** (WHAT) - references tenet:
```yaml
# File: req0002_simplify-requirements-framework.md
id: "0002"
title: "Simple Requirements Framework"
related_tenets: ["simplicity-of-use"]  # WHY we need this
```

**CIP** (HOW) - references requirement:
```yaml
# File: cip0011_component-management.md
id: "0011"
title: "Simplify Component Management"
related_requirements: ["0001", "0002", ...]  # WHAT we're achieving
```

**Backlog** (DO) - references CIP:
```yaml
# File: 2026-01-03_simplify-requirements-framework.md
id: "2026-01-03_simplify-requirements-framework"
related_cips: ["0011"]  # HOW we're implementing it
```

**Scripts query down**: "Show me everything for simplicity tenet"
‚Üí Find requirements where related_tenets contains "simplicity-of-use"
‚Üí Find CIPs where related_requirements contains those requirement IDs
‚Üí Find backlog where related_cips contains those CIP IDs

#### 6.5 AI Assistant Guidance
Decision tree for AI assistants:
```
User request received
    ‚Üì
Does it describe desired outcome?
    YES ‚Üí Create/update requirement (WHAT)
    NO ‚Üí Is it about design/approach?
        YES ‚Üí Create/update CIP (HOW)
        NO ‚Üí Is it ready-to-implement work?
            YES ‚Üí Create backlog task (DO)
```

#### 6.6 Cross-References (Bottom-Up Pattern)

**Enforce the pattern**:
- Requirements MUST have `related_tenets` (which WHY?)
- CIPs MUST have `related_requirements` (which WHAT?)
- Backlog MUST have `related_cips` (which HOW?)

**Validation**:
- Check references point to existing IDs
- Warn if missing (e.g., CIP without related_requirements)
- Don't allow reverse links (e.g., tenets with related_requirements)
- Project summary tool validates relationships

**Testing the Distinction:**
- If requirement reads like implementation ‚Üí Refactor to focus on outcome
- If CIP doesn't reference requirements ‚Üí Ask "What outcome does this achieve?"
- If understanding WHY is hard ‚Üí Outcome isn't clear enough

## Implementation Plan

### Phase 0a: Create Validation Script (1-2 hours) ‚úÖ **COMPLETED 2026-01-03**

**Rationale**: Build the validation tool BEFORE implementing changes, so we can verify our work as we go. This is dogfooding at its best - the tool validates that we're following our own specs from CIP-0011.

- [x] Create `scripts/validate_vibesafe_structure.py` (standalone validation tool)
- [x] **YAML Frontmatter Validation**:
  - [x] Parse all component files (requirements, CIPs, backlog, tenets)
  - [x] Check required fields present for each component type
  - [x] Validate field values (status in allowed list, dates formatted YYYY-MM-DD)
  - [x] Report missing or invalid fields with file path and line number
- [x] **File Naming Validation**:
  - [x] Check requirements match `reqXXXX_short-name.md` pattern
  - [x] Check CIPs match `cipXXXX.md` or `cipXXXX_short-name.md` pattern
  - [x] Check backlog match `YYYY-MM-DD_short-name.md` pattern
  - [x] Check tenets match `short-name.md` pattern (kebab-case)
- [x] **Cross-Reference Validation** (basic):
  - [x] Check requirements reference valid tenet IDs
  - [x] Check CIPs reference valid requirement IDs
  - [x] Check backlog references valid CIP IDs
  - [x] Warn on broken references with suggestion to fix
- [x] **Bottom-Up Pattern Validation**:
  - [x] Warn if requirements have `related_cips` or `related_backlog` (should only have related_tenets)
  - [x] Warn if CIPs have `related_backlog` (should only have related_requirements, related_cips)
  - [x] Warn if backlog has `related_requirements` (should only have related_cips)
  - [x] Warn if tenets have ANY related_ fields (foundation layer)
- [x] **Output Format**:
  - [x] Color-coded: ‚úÖ success, ‚ö†Ô∏è  warnings, ‚ùå errors
  - [x] Group by validation type (YAML, naming, cross-refs, pattern)
  - [x] Show file paths and specific issues
  - [x] Exit code 0 if no errors (warnings OK), 1 if errors
- [x] **Command-line Options**:
  - [x] `--strict` mode (warnings become errors)
  - [x] `--component [req|cip|backlog|tenet]` (validate only specific type)
  - [x] `--fix` mode (auto-fix simple issues like capitalization, missing fields)
  - [x] `--fix-links` mode (fix reverse links - multi-file operation)
  - [x] `--dry-run` mode (preview fixes without applying)
- [x] Refactored to use `python-frontmatter` package (simpler, more robust)
- [x] Comprehensive test suite (32 tests, 100% passing)
- [x] Test script on VibeSafe itself (found and documented issues!)
- [x] Document usage in README

**Deliverable**: ‚úÖ `scripts/validate_vibesafe_structure.py` - our gold standard conformance checker

### Phase 0b: Integrate Validator into Install Script (1-2 hours) ‚úÖ COMPLETED

**Backlog**: `2026-01-03_integrate-validator-install`

Integrate validator into `install-minimal.sh` to ensure quality during installation.

- [x] Add validator execution to `install-minimal.sh` (after deploying system files)
- [x] Run validator in dry-run mode first (`--dry-run --fix --fix-links`)
- [x] Show what would be fixed (colored output with count)
- [x] Prompt user: "Found X issues. Apply fixes? [y/N]"
- [x] If yes: Run with `--fix --fix-links` (apply fixes)
- [x] If no: Continue with warning
- [x] Add `VIBESAFE_SKIP_VALIDATION` environment variable for CI/CD
- [x] Non-interactive mode detection (skips prompt in CI/CD)

**Status**: ‚úÖ Completed 2026-01-03. Validator integrated into installation flow.  
**Deliverable**: Quality-assured installations with optional auto-fix

### Phase 0c: Integrate Validator into What's Next Script (1 hour) ‚úÖ COMPLETED

**Backlog**: `2026-01-03_integrate-validator-whats-next`

Integrate validator into `whats-next` to provide validation feedback in project status.

- [x] Add validator execution to `scripts/whats_next.py` (silent, only show if issues)
- [x] Include validation in "Next Steps" section
- [x] If errors: High-priority next step: "Fix validation errors"
- [x] If warnings: Medium-priority next step: "Address validation warnings"
- [x] Add `--skip-validation` command-line flag

**Status**: ‚úÖ Completed 2026-01-03. Validator integrated into whats-next workflow.  
**Deliverable**: Integrated validation in developer workflow

### Phase 0d: Intelligent Gap Detection & AI-Assisted Suggestions (3-4 hours)

**Backlog**: `2026-01-03_intelligent-gap-detection`

Add intelligent guidance to `whats-next` to detect missing components and provide AI-assisted prompts to bootstrap them.

- [ ] Detect gaps (missing tenets, requirements, CIPs, backlog)
- [ ] Detect codebase presence (source files)
- [ ] Generate AI prompts for missing components:
  - [ ] Tenet extraction from codebase (scan code ‚Üí suggest 3-5 tenets)
  - [ ] Requirement extraction from CIPs (extract WHAT from HOW)
  - [ ] CIP creation from requirements (design HOW for WHAT)
  - [ ] Backlog creation from CIPs (break down into tasks)
- [ ] Show gaps and suggestions in "Next Steps"
- [ ] Provide creation order: Tenets ‚Üí Requirements ‚Üí CIPs ‚Üí Backlog
- [ ] Link requirements to tenets after extraction

**Deliverable**: Intelligent project bootstrapping guidance

### Phase 0: YAML Frontmatter and Naming Standardization ‚úÖ COMPLETED (2026-01-03)

- [x] **Standardize file naming conventions**:
  - [x] Document naming patterns for all component types
  - [x] Requirements: `reqXXXX_short-name.md` (4-digit hex, lowercase)
  - [x] CIPs: `cipXXXX_short-name.md` (4-digit hex, lowercase, short name optional)
  - [x] Backlog: `YYYY-MM-DD_short-name.md` (already consistent)
  - [x] Tenets: `short-name.md` (already consistent)
  - [x] Note: Existing CIPs without short names don't need renaming (optional feature)
- [x] Audit all existing templates (CIP, backlog, requirements, tenets)
- [x] Define standard YAML fields for each component type
- [x] **Add "Deferred" status for CIPs**: Allow CIPs to be marked as postponed/blocked
  - [x] Update validation script to allow `Deferred` in CIP status list
  - [x] Add `blocked_by` field (optional, CIP ID that blocks this one)
  - [x] Add `superseded_by` field (optional, CIP ID that replaces this one)
  - [x] Valid CIP statuses: Proposed, Accepted, **In Progress**, Implemented, Closed, Rejected, **Deferred**
- [x] Update all templates with consistent YAML frontmatter
- [x] **Update CIP template to reference source requirements**:
  - [x] Add `related_requirements` field to YAML frontmatter
  - [x] Add note in template: "CIPs describe HOW to achieve requirements (WHAT)"
  - [x] Add prompt: "Which requirements does this CIP address?"
- [x] **Update backlog template** (enforce bottom-up pattern):
  - [x] Ensure `related_cips` field exists
  - [x] Remove `related_requirements` (violates bottom-up pattern - query through CIPs)
  - [x] Add note: "Backlog tasks are DOING the work defined in CIPs"
- [x] Add YAML validation to parsing scripts (validation script already enforces this)
- [x] Document YAML schema and file naming for each component type (docs/yaml_frontmatter_schema.md)

### Phase 1: Requirements Simplification (2-3 hours)

- [ ] Create new `requirements/` directory structure (optional categorization: functional/, non-functional/, user-research/)
- [ ] Create simple `requirements/README.md` with YAML schema and optional categorization guide
- [ ] **Document WHAT vs HOW distinction in README**:
  - [ ] Explain: Requirements = WHAT should be true (outcomes, desired state)
  - [ ] Explain: CIPs = HOW to achieve it (design, implementation approach)
  - [ ] Explain: Backlog = DOING the work (execution tasks)
  - [ ] Show flow: Requirement ‚Üí CIP ‚Üí Backlog Task ‚Üí Implementation
  - [ ] Provide examples of good requirements (outcome-focused) vs implementation details
  - [ ] Add decision guide: "Am I describing WHAT or HOW?"
- [ ] Create `templates/requirements/requirement_template.md` with YAML frontmatter
- [ ] Migrate existing requirements from `ai-requirements/` to new format
- [ ] Show examples of both flat and categorized requirements structures
- [ ] Update cursor rules to reflect new requirements approach:
  - [ ] Change glob from `ai-requirements/**/*.md` to `requirements/**/*.md`
  - [ ] Remove complex framework description (prompts, patterns in user projects)
  - [ ] Replace with simple requirements format (YAML + description + acceptance criteria)
  - [ ] **Add WHAT vs HOW guidance section**
  - [ ] Add optional categorization guidance
  - [ ] Keep status sync table (still valid)
- [ ] Archive old ai-requirements framework (keep for reference, document deprecation)
- [ ] **Update install-minimal.sh to handle migration (REQ-007, REQ-0008)**:
  - [ ] Detect if ai-requirements/ exists in user project
  - [ ] Offer to migrate to requirements/ (with confirmation)
  - [ ] Update templates to new versions
  - [ ] Preserve all user content during migration
  - [ ] Clear messaging about what's being updated (system files) vs preserved (user content)

### Phase 2: Patterns ‚Üí VibeSafe Guidance (1-2 hours)

- [ ] Move patterns from `ai-requirements/patterns/` to `docs/patterns/` (VibeSafe guidance)
- [ ] Create `docs/patterns/README.md` explaining patterns as thinking tools
- [ ] Keep stakeholder-analysis, goal-decomposition, constraint-mapping as guidance
- [ ] Add examples showing how to apply patterns
- [ ] Update cursor rules to reference patterns as optional resources:
  - [ ] Add section: "Need Help Writing Requirements?"
  - [ ] Link to VibeSafe patterns in `docs/patterns/` as reference material
  - [ ] Clarify patterns are VibeSafe guidance, not user project structure
  - [ ] Show patterns as thinking tools to consult when stuck
- [ ] Remove patterns from user project templates (they're VibeSafe-level, not user-level)

### Phase 3: Tenets Sustainability (1-2 hours)

- [ ] Update tenet template with YAML frontmatter
- [ ] Add review metadata fields (last_reviewed, review_frequency)
- [ ] Create tenet review checklist
- [ ] Add "Last Reviewed" dates to existing tenets
- [ ] **Create VibeSafe Principles script and cursor rule (implements REQ-0008)**:
  - [ ] Create `scripts/generate_vibesafe_principles.py` (separate from combine_tenets.py)
  - [ ] Generates `templates/.cursor/rules/vibesafe-principles.mdc` (single comprehensive cursor rule)
  - [ ] Content includes:
    - All VibeSafe Principles (validation-led, simplicity, user-autonomy, etc.)
    - WHY/WHAT/HOW/DO hierarchy (Tenets ‚Üí Requirements ‚Üí CIPs ‚Üí Backlog)
    - Bottom-up linking pattern explanation
    - Component naming conventions (reqXXXX, cipXXXX, YYYY-MM-DD)
    - Core VibeSafe concepts ("What is VibeSafe?")
    - **Clear boundary explanations (REQ-0008)**:
      - VibeSafe's tenets packaged as "principles" when deployed
      - Namespace separation examples (.venv-vibesafe vs .venv)
      - System files vs user content distinction
  - [ ] Gets deployed to user projects via install-minimal.sh automatically
  - [ ] May consolidate/replace parts of existing cursor rules (avoid duplication)
  - [ ] Distinction: "VibeSafe Principles" (framework) vs "Project Tenets" (user-specific from combine_tenets.py)
- [ ] Document tenet review process in `tenets/README.md`
- [ ] Add tenet conflict detection to `combine_tenets.py`

### Phase 4: Summary Tool (3-4 hours)

- [ ] Create `scripts/project_summary.py` based on `whats_next.py`
- [ ] Add YAML parsing for all component types
- [ ] Add requirements parsing and analysis
- [ ] Add patterns parsing and status
- [ ] Add tenets parsing and review status
- [ ] Add conflict detection between tenets
- [ ] Add cross-reference validation (requirements ‚Üí CIPs ‚Üí backlog)
- [ ] Add recommendations engine
- [ ] Create wrapper script `./project-summary`
- [ ] Update installation scripts to include new tool

### Phase 5: Documentation and Testing (2-3 hours)

- [ ] Update main README with new simplified approach
- [ ] **Add WHAT vs HOW distinction to main documentation**:
  - [ ] Create section explaining the fundamental distinction
  - [ ] Show the flow visually: WHAT ‚Üí HOW ‚Üí DO
  - [ ] Provide examples from VibeSafe itself (dogfooding)
  - [ ] Link from all component READMEs back to this core concept
- [ ] Document YAML frontmatter schema for all components
- [ ] Add examples of requirements, patterns, tenets with new format
- [ ] Create migration guide for existing projects
- [ ] Write tests for `project_summary.py`
- [ ] Update cursor rules with new patterns
- [ ] **Update vibesafe_general.mdc with WHAT vs HOW guidance**:
  - [ ] Add to development practices
  - [ ] Provide decision tree for AI assistants
  - [ ] Examples: "User asks for feature" ‚Üí "Create requirement (WHAT) first"
- [ ] Create visual diagram showing component relationships

## Benefits

1. **Reduced Cognitive Load**: Simple, clear patterns for each component
2. **Better Integration**: Clear relationships between components
3. **Sustainability**: Processes to keep tenets and requirements current
4. **Improved Tooling**: Single command to understand project state
5. **Maintains Simplicity**: Aligns with core VibeSafe tenet

## Risks and Mitigations

**Risk 1: Breaking existing projects using ai-requirements framework**
- *Mitigation*: Keep framework files, mark as deprecated, provide migration guide

**Risk 2: Summary tool becomes complex itself**
- *Mitigation*: Start minimal, add features only if needed, keep defaults simple

**Risk 3: Tenet review process becomes burdensome**
- *Mitigation*: Make it lightweight (10-15 minutes per review), use automated detection

## Alternatives Considered

### Alternative 1: Keep Current System, Just Add Summary Tool
**Rejected**: Doesn't address core complexity problem with requirements

### Alternative 2: Remove Requirements Completely, Use Only CIPs/Backlog
**Rejected**: Some projects need lightweight requirements documentation before CIP-level design

### Alternative 3: Use External Tools (JIRA, GitHub Issues, etc.)
**Rejected**: Breaks VibeSafe's "self-contained" philosophy

## Success Criteria

- [ ] **Phase 0a: Validation script (`validate_vibesafe_structure.py`) working**
- [ ] **Validation passes on VibeSafe itself with no errors**
- [ ] New requirements format documented and usable
- [ ] At least 3 example requirements in new format (‚úÖ have 7!)
- [ ] Existing VibeSafe requirements migrated
- [ ] **WHAT vs HOW distinction documented across all component READMEs**
- [ ] **WHAT vs HOW examples provided (using VibeSafe itself)**
- [ ] **Cursor rules include WHAT vs HOW guidance for AI assistants**
- [ ] **Templates prompt for WHAT vs HOW thinking**
- [ ] Tenet review process documented
- [ ] All existing tenets have review dates
- [ ] `project-summary` script working with test coverage
- [ ] Migration guide for existing projects
- [ ] Dogfooded: VibeSafe itself uses new system successfully
- [ ] **VibeSafe's own requirements demonstrate WHAT (not HOW)**
- [ ] **Validation used throughout implementation to verify conformance**
- [ ] **Clear boundaries maintained (REQ-0008)**:
  - [ ] VibeSafe's tenets packaged as "principles" when deployed
  - [ ] Namespace separation documented (.venv-vibesafe, etc.)
  - [ ] System files vs user content distinction clear
  - [ ] Users can easily identify what's framework vs theirs

## References

- **CIP-000E**: Clean Installation Philosophy (relevant for migration, REQ-0007)
- **CIP-000F**: Gitignore Protection (relevant for new directories)
- **user-autonomy tenet**: Core principle for REQ-0008 (clear boundaries)
- **Simplicity tenet**: Core principle driving this simplification
- **RFC Process**: Inspiration for simple, structured requirements
- **Python PEP Process**: Example of effective requirements ‚Üí design flow

## Open Questions

1. Should requirements have a `requirement_summary.py` script separate from `project_summary.py`?
   - **Leaning toward**: Single `project-summary` tool with flags
2. How do we handle requirements that span multiple projects/repos?
   - **Leaning toward**: Use tags and external references in YAML
3. Should tenet review be automated (script prompts for review) or manual?
   - **Leaning toward**: Automated detection, manual review
4. Do we need a "requirements archive" or just delete completed ones?
   - **Leaning toward**: Archive (helps with project history)
5. Should `project-summary` replace `whats-next` or complement it?
   - **Leaning toward**: Complement (whats-next for quick checks, project-summary for deep analysis)
6. Should patterns be required or optional?
   - **Leaning toward**: Optional - not all projects need user/UX patterns
7. How do we handle YAML schema validation?
   - **Leaning toward**: Soft validation (warnings, not errors) to maintain flexibility

## Notes

This CIP represents a significant simplification of VibeSafe's requirements system while adding sustainability practices for tenets. The key insight is that VibeSafe already has good structures (CIPs, backlog) and we should use them more rather than creating parallel systems.

The complexity of the current ai-requirements framework demonstrates the need for this change - it's a case study in how good intentions (thorough requirements) can create complexity that undermines usability.

