---
id: "0011"
title: "Simplify VibeSafe Component Management: Requirements, Tenets, and Summary Tools"
status: "Proposed"
created: "2026-01-03"
last_updated: "2026-01-03"
author: "Neil Lawrence"
---

# CIP-0011: Simplify VibeSafe Component Management

## Status
- [x] Proposed
- [ ] Accepted
- [ ] Implemented
- [ ] Closed

## Description

This CIP addresses HOW to achieve the outcomes defined in requirements REQ-001 through REQ-005:
- **REQ-001**: Standardized metadata across components
- **REQ-002**: Simple, easy-to-understand requirements framework
- **REQ-003**: Accessible guidance without prescriptive structure
- **REQ-004**: Sustainable tenets that remain relevant
- **REQ-005**: Clear understanding of project status

### Current Problems (Motivating the Requirements)

1. **Lack of Standardization**: Different components use different metadata structures
2. **Requirements Too Complex**: ai-requirements framework has 6 subdirectories and overlapping concepts
3. **Patterns Misplaced**: Teaching materials presented as user project structure
4. **Tenets Drift**: No process to keep tenets aligned with project reality
5. **Fragmented Status**: No single view of project state across all components

## Motivation

### Current Problems

**1. Requirements Are Too Complex**
- The ai-requirements directory has 6 subdirectories and multiple layers
- Users don't know where to put actual requirements
- The framework is more complex than the problems it solves
- Overlap with backlog and CIPs creates confusion

**2. Tenets Lack Sustainability**
- No process for reviewing/updating tenets as projects evolve
- No way to identify stale or conflicting tenets
- No tool to summarize current tenets for quick reference
- Tenets can drift from actual project practices

**3. Summary Tools Are Fragmented**
- `whats-next` only covers backlog/CIPs/git status
- No easy way to see requirements status
- No way to review tenets without reading all files
- Components feel disconnected

### Why This Matters

VibeSafe's value proposition is *simplicity* and *ease of use*. Complex systems that require extensive learning undermine this. We need:
- Clear, simple patterns for each component
- Integration where it makes sense
- Tools that provide quick understanding
- Sustainability processes that prevent drift

## Proposed Solution

### 0. Establish Consistent YAML Frontmatter Across All Components

**All VibeSafe components should use YAML frontmatter for metadata:**

**Common Fields Across All Types:**
```yaml
id: "unique-identifier"
title: "Human-readable title"
status: "Current status"
created: "YYYY-MM-DD"
last_updated: "YYYY-MM-DD"
tags:
  - tag1
  - tag2
```

**Component-Specific Extensions:**

| Component | Additional Fields |
|-----------|------------------|
| **CIP** | `author`, `related_cips`, `related_backlog` |
| **Backlog Task** | `priority`, `category`, `owner`, `dependencies` |
| **Requirement** | `priority`, `related_cips`, `related_backlog`, `stakeholders` |
| **Tenet** | `last_reviewed`, `review_frequency`, `related_cips`, `conflicts_with` |

This enables:
- Automated parsing and analysis
- Cross-referencing between components
- Status tracking and reporting
- Easy filtering and querying

### 1. Simplify Requirements System

**Replace Complex Framework with Simple Integration:**

```
Current Structure (COMPLEX):
ai-requirements/
â”œâ”€â”€ README.md (framework documentation)
â”œâ”€â”€ requirement_template.md
â”œâ”€â”€ prompts/ (discovery, refinement, validation, testing)
â”œâ”€â”€ patterns/ (stakeholder-identification, goal-decomposition)
â”œâ”€â”€ integrations/ (backlog, cip, common)
â”œâ”€â”€ examples/ (4 examples)
â”œâ”€â”€ guidance/ (conversation tips)
â””â”€â”€ [Actual requirement files scattered around]

Proposed Structure (SIMPLE):
requirements/
â”œâ”€â”€ README.md (simple usage guide)
â”œâ”€â”€ REQ-001_feature-name.md
â”œâ”€â”€ REQ-002_another-feature.md
â””â”€â”€ archive/ (completed/rejected requirements)
```

**Simple Requirements Format:**

```markdown
---
id: "REQ-001"
title: "User Authentication"
status: "Proposed"
priority: "High"
created: "2026-01-03"
related_cips: ["0005"]
related_backlog: ["2026-01-03_implement-auth"]
---

# REQ-001: User Authentication

## Description
Brief description of what's needed (2-3 paragraphs max)

## Acceptance Criteria
- [ ] Users can log in with email/password
- [ ] Sessions persist for 24 hours
- [ ] Logout clears all session data

## User Stories (Optional)
As a user, I want to log in so that I can access my data.

## Notes (Optional)
Any additional context, constraints, or considerations
```

**Decision Rules:**
- **Simple requirement** â†’ Create a requirement file in `requirements/`
- **Requirement needs design** â†’ Create a CIP (CIPs are just detailed requirements with implementation plans)
- **Requirement ready to implement** â†’ Create a backlog task
- **Completed requirement** â†’ Move to `requirements/archive/`

### 2. Add Tenets Sustainability Process

**Tenet Lifecycle:**

```
Created â†’ Active â†’ Under Review â†’ Updated/Archived
```

**New Tenet Format with YAML Frontmatter:**

```markdown
---
id: "simplicity-of-use"
title: "Simplicity at All Levels"
status: "Active"
created: "2025-05-05"
last_reviewed: "2026-01-03"
review_frequency: "Annual"
related_cips: ["000E", "0011"]
tags:
  - core-principle
  - usability
---

# Project Tenet: Simplicity at All Levels

## Description
[1-2 paragraphs explaining the principle, its importance, and how it guides decisions]

## Quote
*"[Memorable phrase that captures the essence of the tenet]"*

## Examples
- [Concrete example of applying this tenet]
- [Another example in a different context]

## Counter-examples
- [Example of violating this tenet]
- [Another example of what not to do]

## Conflicts
- [Potential conflict with another tenet]
- Resolution: [How to resolve the conflict]

## Recent Violations (Optional)
Track when we've deviated and learned:
- 2026-01-03: [Brief description and lesson learned]
```

**Review Process:**
1. **Quarterly Tenet Review**: Check if tenets still align with project reality
2. **Track Violations**: When we violate a tenet, document why (maybe tenet needs updating)
3. **Conflict Detection**: Identify when tenets conflict with each other
4. **Usage Tracking**: Which tenets are referenced in CIPs/decisions?

### 3. Create Unified Summary Tool

**New Script: `scripts/project_summary.py`**

Extends `whats-next` with comprehensive project understanding:

```bash
./project-summary                    # Full summary
./project-summary --requirements     # Only requirements
./project-summary --tenets           # Only tenets
./project-summary --status           # Quick status across all components
```

**Output Example:**

```
VibeSafe Project Summary
========================

ðŸ“‹ Requirements Status
- 12 requirements total
- 3 Proposed (need refinement)
- 5 Ready (can start implementation)  
- 4 In Progress (being implemented)
- Oldest unaddressed: REQ-005 (45 days)

ðŸŽ¯ Tenets Status
- 6 active tenets
- 2 need review (>6 months old)
- 1 potential conflict detected (Simplicity vs User Autonomy in CIP-0003)

ðŸ“Š CIPs and Backlog
[Existing whats-next output]

ðŸ’¡ Recommended Next Actions
1. Review REQ-003 (highest priority, no implementation plan)
2. Update "Simplicity" tenet (conflict detected)
3. Complete CIP-0005 (blocking 3 requirements)
```

### 4. Patterns: VibeSafe Guidance vs User Content

**Critical Distinction: VibeSafe Framework vs User Projects**

Patterns are **VibeSafe's pedagogical content** - they teach users HOW to think about requirements. They should NOT be forced into user project structures.

**VibeSafe Level (Framework - Part of VibeSafe Repo):**
```
docs/patterns/              # VibeSafe's teaching/guidance
â”œâ”€â”€ README.md               # "How to think about requirements"
â”œâ”€â”€ stakeholder-analysis.md # Thinking tool (VibeSafe guidance)
â”œâ”€â”€ goal-decomposition.md   # Thinking tool (VibeSafe guidance)
â”œâ”€â”€ constraint-mapping.md   # Thinking tool (VibeSafe guidance)
â””â”€â”€ examples/
    â”œâ”€â”€ user-persona-example.md
    â””â”€â”€ user-journey-example.md
```

These are like a textbook's "how to approach problems" - they're reference material, not project structure.

**User Project Level (Actual Work - In User Repos):**
```
requirements/
â”œâ”€â”€ README.md
â”œâ”€â”€ functional/             # Optional categorization
â”‚   â”œâ”€â”€ REQ-001_user-auth.md
â”‚   â””â”€â”€ REQ-002_data-export.md
â”œâ”€â”€ non-functional/         # Optional categorization
â”‚   â”œâ”€â”€ REQ-010_performance.md
â”‚   â””â”€â”€ REQ-011_security.md
â””â”€â”€ user-research/          # Optional - if project needs it
    â”œâ”€â”€ persona-admin.md
    â””â”€â”€ persona-end-user.md
```

**How Patterns Work:**

1. **VibeSafe provides guidance** in `docs/patterns/`:
   - "Here's how to think about stakeholder analysis"
   - "Here's how to decompose goals"
   - These live in VibeSafe repo, not user repos

2. **Users apply that guidance** in their `requirements/`:
   - Create their actual requirements
   - Optionally categorize by type (functional, non-functional, etc.)
   - Optionally include user research if project needs it

3. **Cursor rules reference patterns**:
   - "Struggling with requirements? See docs/patterns/goal-decomposition.md"
   - Patterns are linked as helpful resources, not mandatory structure

**Requirements Categorization (Optional):**

Users can optionally categorize requirements by:
- **Type**: functional, non-functional, user-facing, technical
- **Priority**: high, medium, low
- **Status**: proposed, ready, in-progress, implemented
- **Stakeholder**: customer-facing, internal, compliance

But categorization is OPTIONAL - simple projects can just have flat `requirements/` directory.

**Example User Project:**

```
# Simple project (no categorization needed)
requirements/
â”œâ”€â”€ REQ-001_user-login.md
â”œâ”€â”€ REQ-002_data-export.md
â””â”€â”€ REQ-003_email-notifications.md

# Complex project (uses categorization)
requirements/
â”œâ”€â”€ functional/
â”‚   â”œâ”€â”€ REQ-001_user-login.md
â”‚   â””â”€â”€ REQ-002_data-export.md
â”œâ”€â”€ non-functional/
â”‚   â”œâ”€â”€ REQ-010_response-time.md
â”‚   â””â”€â”€ REQ-011_data-encryption.md
â””â”€â”€ user-research/
    â”œâ”€â”€ persona-admin.md
    â””â”€â”€ journey-onboarding.md
```

### 5. Integration Philosophy

**Clear Boundaries:**

| Component | Level | Purpose | When to Use |
|-----------|-------|---------|-------------|
| **Patterns** | VibeSafe (Guidance) | HOW to think about requirements | Learning, stuck on requirements discovery |
| **Requirements** | User Project | **WHAT** needs to be built | Starting new features, defining needs |
| **CIPs** | User Project | **HOW** it will be built | Complex features needing technical design |
| **Backlog** | User Project | **DOING** the work | Ready-to-implement tasks |
| **Tenets** | User Project | **WHY** we make decisions | Guiding principles for choices |

**Key Insight:** Patterns are VibeSafe's teaching materials, not user project structure.

**Traceability (User Project Level):**
```
[VibeSafe Patterns - Reference when needed]
                â†“
         Requirements (WHAT) â†’ CIP (HOW) â†’ Backlog Task (DO) â†’ Implementation
                â†“
         Tenets (WHY - inform all decisions)
```

### 6. WHAT vs HOW Distinction - Integration Across VibeSafe

**Fundamental Principle**: Requirements describe **WHAT** should be true (outcomes). CIPs describe **HOW** to achieve it (design). Backlog describes **DOING** the work (execution).

This distinction must be reinforced throughout VibeSafe to prevent confusion between outcomes and implementation.

**Integration Points:**

#### 6.1 Templates
- **CIP Template**: Add `related_requirements` field, note "This CIP describes HOW to achieve requirements"
- **Backlog Template**: Add note "This task is DOING work defined in requirements/CIPs"
- **Requirements Template**: Add note "Requirements describe WHAT should be true (outcomes, not implementation)"

#### 6.2 Documentation
- **requirements/README.md**: Dedicated section on WHAT vs HOW with examples
- **Main README**: Visual flow diagram showing WHAT â†’ HOW â†’ DO
- **CIP README**: Explain CIPs implement requirements
- **Backlog README**: Explain tasks execute CIPs

#### 6.3 Cursor Rules
- **requirements_rule.mdc**: 
  - Add decision guide: "Am I describing WHAT (requirement) or HOW (CIP)?"
  - Examples of good requirements (outcome-focused) vs bad (implementation details)
- **cip.mdc**: Add note about CIPs addressing specific requirements
- **vibesafe_general.mdc**: Add to development practices

#### 6.4 Examples (Dogfooding)
Use VibeSafe's own components as examples:
- **Good Requirement**: "Requirements framework should be simple" (outcome)
- **Bad Requirement**: "Replace ai-requirements with requirements/ directory" (implementation)
- **CIP-0011**: Shows HOW to achieve REQ-001 through REQ-005
- **Backlog Tasks**: Show DOING the work from CIP-0011

#### 6.5 AI Assistant Guidance
Decision tree for AI assistants:
```
User request received
    â†“
Does it describe desired outcome?
    YES â†’ Create/update requirement (WHAT)
    NO â†’ Is it about design/approach?
        YES â†’ Create/update CIP (HOW)
        NO â†’ Is it ready-to-implement work?
            YES â†’ Create backlog task (DO)
```

#### 6.6 Cross-References
- CIPs must reference source requirements
- Backlog tasks should reference CIPs and/or requirements
- Project summary tool validates these relationships

**Testing the Distinction:**
- If requirement reads like implementation â†’ Refactor to focus on outcome
- If CIP doesn't reference requirements â†’ Ask "What outcome does this achieve?"
- If understanding WHY is hard â†’ Outcome isn't clear enough

## Implementation Plan

### Phase 0: YAML Frontmatter Standardization (1-2 hours)

- [ ] Audit all existing templates (CIP, backlog, requirements, tenets)
- [ ] Define standard YAML fields for each component type
- [ ] Update all templates with consistent YAML frontmatter
- [ ] **Update CIP template to reference source requirements**:
  - [ ] Add `related_requirements` field to YAML frontmatter
  - [ ] Add note in template: "CIPs describe HOW to achieve requirements (WHAT)"
  - [ ] Add prompt: "Which requirements does this CIP address?"
- [ ] **Update backlog template to reference requirements and CIPs**:
  - [ ] Ensure `related_cips` and optionally `related_requirements` fields exist
  - [ ] Add note: "Backlog tasks are DOING the work defined in requirements/CIPs"
- [ ] Add YAML validation to parsing scripts
- [ ] Document YAML schema for each component type

### Phase 1: Requirements Simplification (2-3 hours)

- [ ] Create new `requirements/` directory structure (optional categorization: functional/, non-functional/, user-research/)
- [ ] Create simple `requirements/README.md` with YAML schema and optional categorization guide
- [ ] **Document WHAT vs HOW distinction in README**:
  - [ ] Explain: Requirements = WHAT should be true (outcomes, desired state)
  - [ ] Explain: CIPs = HOW to achieve it (design, implementation approach)
  - [ ] Explain: Backlog = DOING the work (execution tasks)
  - [ ] Show flow: Requirement â†’ CIP â†’ Backlog Task â†’ Implementation
  - [ ] Provide examples of good requirements (outcome-focused) vs implementation details
  - [ ] Add decision guide: "Am I describing WHAT or HOW?"
- [ ] Create `templates/requirements/requirement_template.md` with YAML frontmatter
- [ ] Migrate existing requirements from `ai-requirements/` to new format
- [ ] Show examples of both flat and categorized requirements structures
- [ ] Update cursor rules to reflect new requirements approach:
  - [ ] Change glob from `ai-requirements/**/*.md` to `requirements/**/*.md`
  - [ ] Remove complex framework description (prompts, patterns in user projects)
  - [ ] Replace with simple requirements format (YAML + description + acceptance criteria)
  - [ ] **Add WHAT vs HOW guidance section**
  - [ ] Add optional categorization guidance
  - [ ] Keep status sync table (still valid)
- [ ] Archive old ai-requirements framework (keep for reference, document deprecation)

### Phase 2: Patterns â†’ VibeSafe Guidance (1-2 hours)

- [ ] Move patterns from `ai-requirements/patterns/` to `docs/patterns/` (VibeSafe guidance)
- [ ] Create `docs/patterns/README.md` explaining patterns as thinking tools
- [ ] Keep stakeholder-analysis, goal-decomposition, constraint-mapping as guidance
- [ ] Add examples showing how to apply patterns
- [ ] Update cursor rules to reference patterns as optional resources:
  - [ ] Add section: "Need Help Writing Requirements?"
  - [ ] Link to VibeSafe patterns in `docs/patterns/` as reference material
  - [ ] Clarify patterns are VibeSafe guidance, not user project structure
  - [ ] Show patterns as thinking tools to consult when stuck
- [ ] Remove patterns from user project templates (they're VibeSafe-level, not user-level)

### Phase 3: Tenets Sustainability (1-2 hours)

- [ ] Update tenet template with YAML frontmatter
- [ ] Add review metadata fields (last_reviewed, review_frequency)
- [ ] Create tenet review checklist
- [ ] Add "Last Reviewed" dates to existing tenets
- [ ] Document tenet review process in `tenets/README.md`
- [ ] Add tenet conflict detection to `combine_tenets.py`

### Phase 4: Summary Tool (3-4 hours)

- [ ] Create `scripts/project_summary.py` based on `whats_next.py`
- [ ] Add YAML parsing for all component types
- [ ] Add requirements parsing and analysis
- [ ] Add patterns parsing and status
- [ ] Add tenets parsing and review status
- [ ] Add conflict detection between tenets
- [ ] Add cross-reference validation (requirements â†’ CIPs â†’ backlog)
- [ ] Add recommendations engine
- [ ] Create wrapper script `./project-summary`
- [ ] Update installation scripts to include new tool

### Phase 5: Documentation and Testing (2-3 hours)

- [ ] Update main README with new simplified approach
- [ ] **Add WHAT vs HOW distinction to main documentation**:
  - [ ] Create section explaining the fundamental distinction
  - [ ] Show the flow visually: WHAT â†’ HOW â†’ DO
  - [ ] Provide examples from VibeSafe itself (dogfooding)
  - [ ] Link from all component READMEs back to this core concept
- [ ] Document YAML frontmatter schema for all components
- [ ] Add examples of requirements, patterns, tenets with new format
- [ ] Create migration guide for existing projects
- [ ] Write tests for `project_summary.py`
- [ ] Update cursor rules with new patterns
- [ ] **Update vibesafe_general.mdc with WHAT vs HOW guidance**:
  - [ ] Add to development practices
  - [ ] Provide decision tree for AI assistants
  - [ ] Examples: "User asks for feature" â†’ "Create requirement (WHAT) first"
- [ ] Create visual diagram showing component relationships

## Benefits

1. **Reduced Cognitive Load**: Simple, clear patterns for each component
2. **Better Integration**: Clear relationships between components
3. **Sustainability**: Processes to keep tenets and requirements current
4. **Improved Tooling**: Single command to understand project state
5. **Maintains Simplicity**: Aligns with core VibeSafe tenet

## Risks and Mitigations

**Risk 1: Breaking existing projects using ai-requirements framework**
- *Mitigation*: Keep framework files, mark as deprecated, provide migration guide

**Risk 2: Summary tool becomes complex itself**
- *Mitigation*: Start minimal, add features only if needed, keep defaults simple

**Risk 3: Tenet review process becomes burdensome**
- *Mitigation*: Make it lightweight (10-15 minutes per review), use automated detection

## Alternatives Considered

### Alternative 1: Keep Current System, Just Add Summary Tool
**Rejected**: Doesn't address core complexity problem with requirements

### Alternative 2: Remove Requirements Completely, Use Only CIPs/Backlog
**Rejected**: Some projects need lightweight requirements documentation before CIP-level design

### Alternative 3: Use External Tools (JIRA, GitHub Issues, etc.)
**Rejected**: Breaks VibeSafe's "self-contained" philosophy

## Success Criteria

- [ ] New requirements format documented and usable
- [ ] At least 3 example requirements in new format
- [ ] Existing VibeSafe requirements migrated
- [ ] **WHAT vs HOW distinction documented across all component READMEs**
- [ ] **WHAT vs HOW examples provided (using VibeSafe itself)**
- [ ] **Cursor rules include WHAT vs HOW guidance for AI assistants**
- [ ] **Templates prompt for WHAT vs HOW thinking**
- [ ] Tenet review process documented
- [ ] All existing tenets have review dates
- [ ] `project-summary` script working with test coverage
- [ ] Migration guide for existing projects
- [ ] Dogfooded: VibeSafe itself uses new system successfully
- [ ] **VibeSafe's own requirements demonstrate WHAT (not HOW)**

## References

- **CIP-000E**: Clean Installation Philosophy (relevant for migration)
- **CIP-000F**: Gitignore Protection (relevant for new directories)
- **Simplicity Tenet**: Core principle driving this simplification
- **RFC Process**: Inspiration for simple, structured requirements
- **Python PEP Process**: Example of effective requirements â†’ design flow

## Open Questions

1. Should requirements have a `requirement_summary.py` script separate from `project_summary.py`?
   - **Leaning toward**: Single `project-summary` tool with flags
2. How do we handle requirements that span multiple projects/repos?
   - **Leaning toward**: Use tags and external references in YAML
3. Should tenet review be automated (script prompts for review) or manual?
   - **Leaning toward**: Automated detection, manual review
4. Do we need a "requirements archive" or just delete completed ones?
   - **Leaning toward**: Archive (helps with project history)
5. Should `project-summary` replace `whats-next` or complement it?
   - **Leaning toward**: Complement (whats-next for quick checks, project-summary for deep analysis)
6. Should patterns be required or optional?
   - **Leaning toward**: Optional - not all projects need user/UX patterns
7. How do we handle YAML schema validation?
   - **Leaning toward**: Soft validation (warnings, not errors) to maintain flexibility

## Notes

This CIP represents a significant simplification of VibeSafe's requirements system while adding sustainability practices for tenets. The key insight is that VibeSafe already has good structures (CIPs, backlog) and we should use them more rather than creating parallel systems.

The complexity of the current ai-requirements framework demonstrates the need for this change - it's a case study in how good intentions (thorough requirements) can create complexity that undermines usability.

