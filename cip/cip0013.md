---
author: "Neil Lawrence"
created: "2026-01-08"
id: "0013"
last_updated: "2026-01-08"
status: "Closed"
compressed: false  # Ready for compression - this CIP itself will be compressed first!
related_requirements: ["000E", "000F"]  # Documentation Synchronization + Structure Specification
related_cips: ["0007"]  # Documentation and Implementation as Unified Whole
tags:
- cip
- documentation
- workflow
- compression
- knowledge-management
title: "Documentation Compression Stage"
---

# CIP-0013: Documentation Compression Stage

> **Note**: CIPs describe HOW to achieve requirements (WHAT).  
> This CIP establishes a systematic "compression stage" for consolidating implementation knowledge into formal documentation.

## Status

- [x] Proposed - Initial idea documented
- [x] Accepted - Approved, ready to create backlog tasks and start work
- [x] In Progress - Actively being implemented (all phases complete)
- [x] Implemented - Work complete, awaiting verification
- [x] Closed - Verified and complete through dogfooding! ✅
- [ ] Rejected - Will not be implemented (add reason, use superseded_by if replaced)
- [ ] Deferred - Postponed (use blocked_by field to indicate blocker)

## Summary

Implement a systematic "compression stage" in the VibeSafe workflow that consolidates knowledge from closed CIPs, completed requirements, and finalized implementations into formal documentation. This stage compresses the detailed evolution (WHY→WHAT→HOW→DO) into permanent, accessible documentation (DOCUMENT).

**The Compression Metaphor**: During active development, information is "expanded" across CIPs (design rationale), backlog tasks (implementation details), and code (actual behavior). After completion, this information should be "compressed" into streamlined formal documentation that future users can understand without reading the entire development history.

**Which requirements does this CIP address?** REQ-000E (Documentation Synchronization with Implementation)

## Motivation

### The Problem

Currently, VibeSafe has implicit guidance about updating formal documentation "after implementation is complete," but no systematic process for:

1. **When** compression should happen (trigger conditions)
2. **What** gets compressed (which artifacts)
3. **Where** compressed knowledge goes (destination docs)
4. **How** to perform compression (workflow, checklists)
5. **Who** is responsible (role assignment)

This leads to:
- Closed CIPs that never get reflected in formal documentation
- README and philosophy documents that fall out of sync with implementation
- Users reading 50+ closed CIPs to understand current architecture
- AI assistants lacking compressed context about finalized decisions

### The Solution

A systematic compression stage that:
- Triggers automatically when CIPs close
- Provides clear checklists for what to update
- Produces artifacts (updated README, Sphinx docs, architecture docs)
- Integrates with `whats-next` to surface compression tasks
- Creates a feedback loop: formal docs validate that implementation matches design

### Alignment with Existing Tenets

**Documentation and Implementation as a Unified Whole** (from CIP-0007):
> *"Document to guide implementation; implement to validate documentation."*

Compression is the validation phase where implementation proves the design, and formal documentation captures the validated outcome.

## Detailed Description

### The Five-Stage Workflow

```
WHY (Tenets) → WHAT (Requirements) → HOW (CIPs) → DO (Backlog) → DOCUMENT (Compression)
     ↑                                                                      ↓
     └─────────────────────── feedback loop ──────────────────────────────┘
```

**Compression Stage Goal**: Transform detailed development artifacts into permanent, accessible documentation.

### What Gets Compressed?

| Source | Destination | What to Extract |
|--------|-------------|-----------------|
| **Closed CIPs** | `docs/architecture.md` or Sphinx | Final design decisions, architecture rationale |
| **Closed CIPs** | `README.md` | High-level feature descriptions |
| **Validated Requirements** | `docs/requirements.md` or Sphinx | Acceptance criteria met, traceability |
| **Completed Backlog** | *Remove/Archive* | Implementation details (already in code/tests) |
| **Code + Tests** | `docs/api.md` or Sphinx | API documentation, usage examples |

### When Compression Happens

**Triggers**:
1. **After CIP Closure**: When status changes to "Closed"
2. **After Requirement Validation**: When status changes to "Validated"
3. **Periodic Review**: Quarterly review of all closed-but-not-compressed CIPs
4. **Before Major Release**: Ensure all release features are compressed

### Compression Workflow

**Phase 1: Identify Compression Candidates** (automated via `whats-next`)
```bash
./whats-next --compression-check
# Output: "3 closed CIPs need documentation compression"
```

**Phase 2: Perform Compression** (human-driven, checklist-guided)
1. Read closed CIP(s)
2. Extract key decisions, rationale, outcomes
3. Update formal documentation (README, Sphinx, etc.)
4. Create examples/tutorials if needed
5. Mark CIP as "compressed" (metadata field)

**Phase 3: Validate Compression**
1. Verify formal docs reflect implementation
2. Check links/references work
3. Test examples/tutorials
4. Commit with message: "Compress CIP-XXXX into formal documentation"

### Artifacts Produced

1. **Updated README.md**: High-level feature list, architecture overview
2. **Updated Sphinx/docs/**: Detailed API docs, tutorials, architecture guides
3. **Compression Log**: Track which CIPs have been compressed (metadata or separate file)
4. **Archived Backlog**: Move completed tasks to archive (optional)

## Implementation Plan

### Phase 0: Add Compression Metadata
- [ ] Add `compressed: false` field to CIP YAML frontmatter
- [ ] Update CIP template with compression field
- [ ] Add compression status to `whats-next` output

### Phase 1: Compression Checklist Template
- [ ] Create `templates/compression_checklist.md`
- [ ] Define per-CIP compression tasks (update README, Sphinx, etc.)
- [ ] Create examples for different types of CIPs (infrastructure, features, process)

### Phase 2: Integration with `whats-next`
Implement the 8 prompt triggers from REQ-000E:

- [ ] **Trigger 1**: Detect closed CIPs without `compressed: true` metadata
- [ ] **Trigger 2**: Calculate days since CIP closure, suggest compression after 30 days
- [ ] **Trigger 3**: Verify formal docs reference CIP numbers when `compressed: true`
- [ ] **Trigger 4**: Detect validated requirements without formal doc updates
- [ ] **Trigger 5**: List closed CIPs lacking `compressed: true` in main output
- [ ] **Trigger 6**: Add `--compression-check` flag for focused compression view
- [ ] **Trigger 7**: Detect multiple recent CIP closures, suggest batch compression
- [ ] **Trigger 8**: Auto-generate compression backlog task with checklist when suggested

**Implementation Details**:
- Parse CIP YAML frontmatter for `status: "Closed"` and `compressed: true`
- Compare CIP `last_updated` date with current date for age calculation
- Prioritize suggestions: older CIPs first, high-priority CIPs emphasized
- Format output: "3 closed CIPs need compression (CIP-0012: 35 days, CIP-0013: 2 days, CIP-0014: 1 day)"
- Respect user autonomy: prompts are suggestions, not blockers

### Phase 3: Documentation Structure
- [ ] Document detection logic for user's documentation system (Sphinx, MkDocs, plain markdown, minimal)
- [ ] Provide adaptive compression targets based on detected structure
- [ ] Document style guide for compression (WHAT→WHY→HOW→TRACE)
- [ ] Respect User Autonomy: detect, don't prescribe (no forced structure)
- [ ] **After CIP closes**: Create formal docs/compression-guide.md from this CIP

### Phase 4: Workflow Integration
- [ ] Update CIP workflow to include compression step
- [ ] Add natural breakpoint: CIP Closed → Pause for compression
- [ ] Create example compression commits for reference

### Phase 5: Periodic Review Process
- [x] Define quarterly compression review process
- [x] Create quarterly review template (`templates/quarterly_compression_review_template.md`)
- [x] Establish compression quality metrics (4 metrics with targets)
- [x] Document periodic review workflow in CIP-0013

## Backward Compatibility

**Existing CIPs**: 
- No immediate action required
- Gradually compress high-value closed CIPs
- Prioritize recent/important CIPs first

**Existing Documentation**:
- README already serves as compression target (no change)
- New Sphinx docs extend, don't replace existing docs

**Workflow**:
- Compression is optional but recommended
- Doesn't block CIP closure
- Enhances but doesn't gate the development process

## Testing Strategy

**Manual Testing**:
1. Close a test CIP and perform compression
2. Verify compressed docs accurately reflect CIP decisions
3. Check that `whats-next` correctly identifies compression needs

**Automated Testing**:
1. Script to check for closed CIPs without `compressed: true`
2. Lint check for broken links in compressed documentation
3. Test `whats-next --compression-check` output

**Success Metrics**:
- 80%+ of closed CIPs compressed within 30 days
- Formal documentation accurately reflects all closed CIPs
- Users/AI assistants find answers in docs without reading CIP history

## Related Requirements

REQ-000E: Documentation Synchronization with Implementation
- Establishes the desired outcome (WHAT): Formal documentation reflects all closed CIPs and validated requirements
- This CIP defines HOW to achieve that outcome through a systematic compression stage

## Implementation Status

- [x] Phase 0: Add compression metadata to CIP format ✅ (2026-01-08)
- [x] Phase 1: Create compression checklist template ✅ (2026-01-08)
- [x] Phase 2: Integrate with `whats-next` script ✅ (2026-01-08)
- [x] Phase 3: Establish documentation structure ✅ (2026-01-08)
- [x] Phase 4: Workflow integration ✅ (2026-01-08)
- [x] Phase 5: Periodic review process ✅ (2026-01-08)

**All phases complete!** CIP-0013 implementation finished on 2026-01-08.

## Validation (Dogfooding)

**Date**: 2026-01-08 (same day as implementation)

**Method**: Tested installation process with local changes using `VIBESAFE_SKIP_CLONE=true` and `VIBESAFE_TEMPLATES_DIR`.

**Findings**:
1. ✅ **Multi-platform generation working** (CIP-0012): All platforms (Cursor, Copilot, Claude, Codex) generated successfully
2. ✅ **Compression metadata in CIP template**: `compressed: false` field present
3. ✅ **`--compression-check` flag working**: Phase 2 integration successful
4. ❌ **Base prompts missing compression guidance**: Discovered templates/.cursor/rules/*.mdc were updated but templates/prompts/*.md were not

**Bug Fixed**: Updated `templates/prompts/context-specific/cip.md` and `templates/prompts/always-apply/vibesafe_general.md` to include:
- 6th natural breakpoint (compression after CIP closure)
- 4-phase documentation lifecycle (was 3-phase)
- Updated workflow examples and tables

**Retest Results**: ✅ All platforms now have compression guidance

**Conclusion**: CIP-0013 validated through dogfooding. Bug discovered and fixed same day. Installation process works correctly with all compression features.

## Compression Guide (Integrated Design Documentation)

> **Per REQ-000D**: CIPs are self-contained design documents. This section contains the compression guide that will become `docs/compression-guide.md` after this CIP closes.

### Documentation Structure Detection

VibeSafe **detects** your existing documentation structure and adapts guidance accordingly. We never force a specific system.

**Detection Logic**:

| Check | Result | Suggested Targets |
|-------|--------|-------------------|
| `docs/conf.py` exists? | **Sphinx** | `docs/source/*.rst` + README.md |
| `mkdocs.yml` exists? | **MkDocs** | `docs/*.md` + README.md |
| `docs/*.md` exist? | **Plain Markdown** | `docs/*.md` + README.md |
| None of above? | **Minimal** | README.md + optional `docs/` |

### Adaptive Compression Targets

**For Sphinx Users**:
- Infrastructure CIPs → `docs/source/architecture.rst`
- Feature CIPs → `docs/source/features.rst`
- Process CIPs → `docs/source/workflow.rst`
- High-level → `README.md`

**For MkDocs/Plain Markdown Users**:
- Infrastructure CIPs → `docs/architecture.md`
- Feature CIPs → `docs/features.md`
- Process CIPs → `docs/workflow.md`
- High-level → `README.md`

**For Minimal Users**:
- Start with `README.md` sections
- Create `docs/` when it grows

### Style Guide for Compression

**Structure**: WHAT → WHY → HOW (high-level) → TRACE

**Balance Detail and Brevity**:
- ❌ Too brief: "Added search" (no context)
- ❌ Too detailed: "Implemented BM25 algorithm with tf-idf weighting..." (belongs in CIP)
- ✅ Just right: "Full-text search with semantic indexing. See [CIP-00XX](cip00XX.md) for details"

**Examples by Length**:

*One-paragraph (README)*:
```markdown
## Multi-Platform AI Assistant Support
VibeSafe works with Cursor, Copilot, Claude, and Codex. See [CIP-0012](cip/cip0012.md).
```

*Two-paragraph (docs/features.md)*:
```markdown
## Multi-Platform AI Assistant Support

VibeSafe generates prompts for Cursor, Copilot, Claude, and Codex from `templates/prompts/`. 
Users select platform via `VIBESAFE_PLATFORM` during installation.

**Architecture**: Platform-agnostic base → install-time generation → platform-specific files.
See [CIP-0012](../cip/cip0012.md) for detailed rationale.
```

### Traceability Formats

**Always link docs → CIP**:

*Inline*:
```markdown
Multi-platform support ([CIP-0012](cip/cip0012.md)) enables...
```

*Footer*:
```markdown
**Design**: [CIP-0012](cip/cip0012.md) | **Requirements**: [REQ-000C](requirements/req000C.md)
```

### Configuration Override

**Optional** `.vibesafe/compression.yml`:
```yaml
compression:
  system: "sphinx"  # Override detection
  targets:
    infrastructure: "docs/my-architecture.md"
    feature: "docs/features/"
    process: "docs/workflow.md"
  format: "markdown"
  traceability: "inline"
```

### Compression Workflow

1. **Identify**: `./whats-next --compression-check`
2. **Copy template**: `cp templates/compression_checklist.md cip/cip0012-compression.md`
3. **Read CIP**: Identify key decisions, outcomes
4. **Choose targets**: Use detection-based suggestions or config
5. **Write compressed docs**: Follow WHAT→WHY→HOW→TRACE
6. **Mark compressed**: Set `compressed: true` in CIP
7. **Commit**: `git commit -m "Compress CIP-XXXX"`

### When to Skip Compression

- Minor/internal changes
- Rejected CIPs
- Superseded CIPs (compress the replacement)
- Implementation details only (fully in code/tests)

### Periodic Compression Review

**Why periodic reviews?** While `whats-next` prompts help, periodic reviews ensure nothing is forgotten. Quarterly rhythm provides natural checkpoints for documentation maintenance.

**Quarterly Review Workflow**:

1. **Check Status**: `./whats-next --compression-check`
2. **Prioritize**: Which CIPs are critical to document? Which can wait?
3. **Batch Compress**: Work through high-value CIPs using compression checklist
4. **Update Metrics**: Track compression quality (see below)
5. **Reflect**: What went well? What slipped through? Adjust workflow if needed

**Compression Quality Metrics** (track quarterly):

| Metric | Target | Why |
|--------|--------|-----|
| 30-day compliance | >80% | Most CIPs compressed quickly |
| 90-day compliance | >95% | Nearly all CIPs compressed eventually |
| Uncompressed backlog | <5 CIPs | Manageable queue |
| Oldest uncompressed | <120 days | Nothing forgotten >4 months |

**Template**: `templates/quarterly_compression_review_template.md`

**Creating Quarterly Review Tasks**:
```bash
# At end of each quarter (or start of next)
cp templates/quarterly_compression_review_template.md \
   backlog/documentation/2026-Q2_quarterly-compression-review.md
# Edit dates, quarter number, set status to "Ready"
```

**First Review**: Recommend Q2 2026 (Apr-Jun) as the first periodic review, allowing time for initial CIPs to close and establish baseline metrics.

## References

- CIP-0007: Documentation and Implementation as a Unified Whole
- CIP-0012: AI Assistant Framework Independence (example of completed compression)
- VibeSafe General Development Guidelines: "Documentation Lifecycle"
- REQ-000D: CIPs as Self-Contained Design Documents

## Notes

### Example Compression

**Before Compression**:
- User reads 4-phase CIP with 15 pages of implementation details
- Scattered across CIP, 4 backlog tasks, 50+ commits
- Takes 30 minutes to understand what was built

**After Compression**:
- README: "VibeSafe now supports Cursor, Copilot, Claude, and Codex"
- Sphinx docs: Installation guide with `VIBESAFE_PLATFORM` examples
- Architecture doc: "Platform-agnostic prompts in `templates/prompts/`"
- Takes 5 minutes to understand current state

### Compression is NOT

- ❌ Deleting CIPs (they remain for historical reference)
- ❌ Rewriting CIPs (they stay as-is, documenting the journey)
- ❌ Creating duplicate documentation (extract essence, don't copy)
- ❌ Required before CIP closure (recommended after)

### Compression IS

- ✅ Extracting essential knowledge from development artifacts
- ✅ Creating accessible documentation for future users
- ✅ Validating that implementation matches design intent
- ✅ Closing the feedback loop: WHY→WHAT→HOW→DO→DOCUMENT→WHY

