---
author: "Neil Lawrence"
created: "2026-01-08"
id: "0013"
last_updated: "2026-01-08"
status: "In Progress"
related_requirements: ["000E"]  # Documentation Synchronization
related_cips: ["0007"]  # Documentation and Implementation as Unified Whole
tags:
- cip
- documentation
- workflow
- compression
- knowledge-management
title: "Documentation Compression Stage"
---

# CIP-0013: Documentation Compression Stage

> **Note**: CIPs describe HOW to achieve requirements (WHAT).  
> This CIP establishes a systematic "compression stage" for consolidating implementation knowledge into formal documentation.

## Status

- [x] Proposed - Initial idea documented
- [x] Accepted - Approved, ready to create backlog tasks and start work
- [x] In Progress - Actively being implemented (Phase 0 complete, Phase 1 starting)
- [ ] Implemented - Work complete, awaiting verification
- [ ] Closed - Verified and complete
- [ ] Rejected - Will not be implemented (add reason, use superseded_by if replaced)
- [ ] Deferred - Postponed (use blocked_by field to indicate blocker)

## Summary

Implement a systematic "compression stage" in the VibeSafe workflow that consolidates knowledge from closed CIPs, completed requirements, and finalized implementations into formal documentation. This stage compresses the detailed evolution (WHY→WHAT→HOW→DO) into permanent, accessible documentation (DOCUMENT).

**The Compression Metaphor**: During active development, information is "expanded" across CIPs (design rationale), backlog tasks (implementation details), and code (actual behavior). After completion, this information should be "compressed" into streamlined formal documentation that future users can understand without reading the entire development history.

**Which requirements does this CIP address?** REQ-000E (Documentation Synchronization with Implementation)

## Motivation

### The Problem

Currently, VibeSafe has implicit guidance about updating formal documentation "after implementation is complete," but no systematic process for:

1. **When** compression should happen (trigger conditions)
2. **What** gets compressed (which artifacts)
3. **Where** compressed knowledge goes (destination docs)
4. **How** to perform compression (workflow, checklists)
5. **Who** is responsible (role assignment)

This leads to:
- Closed CIPs that never get reflected in formal documentation
- README and philosophy documents that fall out of sync with implementation
- Users reading 50+ closed CIPs to understand current architecture
- AI assistants lacking compressed context about finalized decisions

### The Solution

A systematic compression stage that:
- Triggers automatically when CIPs close
- Provides clear checklists for what to update
- Produces artifacts (updated README, Sphinx docs, architecture docs)
- Integrates with `whats-next` to surface compression tasks
- Creates a feedback loop: formal docs validate that implementation matches design

### Alignment with Existing Tenets

**Documentation and Implementation as a Unified Whole** (from CIP-0007):
> *"Document to guide implementation; implement to validate documentation."*

Compression is the validation phase where implementation proves the design, and formal documentation captures the validated outcome.

## Detailed Description

### The Five-Stage Workflow

```
WHY (Tenets) → WHAT (Requirements) → HOW (CIPs) → DO (Backlog) → DOCUMENT (Compression)
     ↑                                                                      ↓
     └─────────────────────── feedback loop ──────────────────────────────┘
```

**Compression Stage Goal**: Transform detailed development artifacts into permanent, accessible documentation.

### What Gets Compressed?

| Source | Destination | What to Extract |
|--------|-------------|-----------------|
| **Closed CIPs** | `docs/architecture.md` or Sphinx | Final design decisions, architecture rationale |
| **Closed CIPs** | `README.md` | High-level feature descriptions |
| **Validated Requirements** | `docs/requirements.md` or Sphinx | Acceptance criteria met, traceability |
| **Completed Backlog** | *Remove/Archive* | Implementation details (already in code/tests) |
| **Code + Tests** | `docs/api.md` or Sphinx | API documentation, usage examples |

### When Compression Happens

**Triggers**:
1. **After CIP Closure**: When status changes to "Closed"
2. **After Requirement Validation**: When status changes to "Validated"
3. **Periodic Review**: Quarterly review of all closed-but-not-compressed CIPs
4. **Before Major Release**: Ensure all release features are compressed

### Compression Workflow

**Phase 1: Identify Compression Candidates** (automated via `whats-next`)
```bash
./whats-next --compression-check
# Output: "3 closed CIPs need documentation compression"
```

**Phase 2: Perform Compression** (human-driven, checklist-guided)
1. Read closed CIP(s)
2. Extract key decisions, rationale, outcomes
3. Update formal documentation (README, Sphinx, etc.)
4. Create examples/tutorials if needed
5. Mark CIP as "compressed" (metadata field)

**Phase 3: Validate Compression**
1. Verify formal docs reflect implementation
2. Check links/references work
3. Test examples/tutorials
4. Commit with message: "Compress CIP-XXXX into formal documentation"

### Artifacts Produced

1. **Updated README.md**: High-level feature list, architecture overview
2. **Updated Sphinx/docs/**: Detailed API docs, tutorials, architecture guides
3. **Compression Log**: Track which CIPs have been compressed (metadata or separate file)
4. **Archived Backlog**: Move completed tasks to archive (optional)

## Implementation Plan

### Phase 0: Add Compression Metadata
- [ ] Add `compressed: false` field to CIP YAML frontmatter
- [ ] Update CIP template with compression field
- [ ] Add compression status to `whats-next` output

### Phase 1: Compression Checklist Template
- [ ] Create `templates/compression_checklist.md`
- [ ] Define per-CIP compression tasks (update README, Sphinx, etc.)
- [ ] Create examples for different types of CIPs (infrastructure, features, process)

### Phase 2: Integration with `whats-next`
Implement the 8 prompt triggers from REQ-000E:

- [ ] **Trigger 1**: Detect closed CIPs without `compressed: true` metadata
- [ ] **Trigger 2**: Calculate days since CIP closure, suggest compression after 30 days
- [ ] **Trigger 3**: Verify formal docs reference CIP numbers when `compressed: true`
- [ ] **Trigger 4**: Detect validated requirements without formal doc updates
- [ ] **Trigger 5**: List closed CIPs lacking `compressed: true` in main output
- [ ] **Trigger 6**: Add `--compression-check` flag for focused compression view
- [ ] **Trigger 7**: Detect multiple recent CIP closures, suggest batch compression
- [ ] **Trigger 8**: Auto-generate compression backlog task with checklist when suggested

**Implementation Details**:
- Parse CIP YAML frontmatter for `status: "Closed"` and `compressed: true`
- Compare CIP `last_updated` date with current date for age calculation
- Prioritize suggestions: older CIPs first, high-priority CIPs emphasized
- Format output: "3 closed CIPs need compression (CIP-0012: 35 days, CIP-0013: 2 days, CIP-0014: 1 day)"
- Respect user autonomy: prompts are suggestions, not blockers

### Phase 3: Documentation Structure
- [ ] Create or update `docs/architecture.md` as compression target
- [ ] Establish Sphinx documentation structure (if not exists)
- [ ] Create `docs/compression-guide.md` with workflow details

### Phase 4: Workflow Integration
- [ ] Update CIP workflow to include compression step
- [ ] Add natural breakpoint: CIP Closed → Pause for compression
- [ ] Create example compression commits for reference

### Phase 5: Periodic Review Process
- [ ] Define quarterly compression review process
- [ ] Create backlog task for periodic compression reviews
- [ ] Establish compression quality metrics

## Backward Compatibility

**Existing CIPs**: 
- No immediate action required
- Gradually compress high-value closed CIPs
- Prioritize recent/important CIPs first

**Existing Documentation**:
- README already serves as compression target (no change)
- New Sphinx docs extend, don't replace existing docs

**Workflow**:
- Compression is optional but recommended
- Doesn't block CIP closure
- Enhances but doesn't gate the development process

## Testing Strategy

**Manual Testing**:
1. Close a test CIP and perform compression
2. Verify compressed docs accurately reflect CIP decisions
3. Check that `whats-next` correctly identifies compression needs

**Automated Testing**:
1. Script to check for closed CIPs without `compressed: true`
2. Lint check for broken links in compressed documentation
3. Test `whats-next --compression-check` output

**Success Metrics**:
- 80%+ of closed CIPs compressed within 30 days
- Formal documentation accurately reflects all closed CIPs
- Users/AI assistants find answers in docs without reading CIP history

## Related Requirements

REQ-000E: Documentation Synchronization with Implementation
- Establishes the desired outcome (WHAT): Formal documentation reflects all closed CIPs and validated requirements
- This CIP defines HOW to achieve that outcome through a systematic compression stage

## Implementation Status

- [x] Phase 0: Add compression metadata to CIP format ✅ (2026-01-08)
- [ ] Phase 1: Create compression checklist template
- [ ] Phase 2: Integrate with `whats-next` script
- [ ] Phase 3: Establish documentation structure
- [ ] Phase 4: Workflow integration
- [ ] Phase 5: Periodic review process

## References

- CIP-0007: Documentation and Implementation as a Unified Whole
- CIP-0012: AI Assistant Framework Independence (example of completed compression)
- VibeSafe General Development Guidelines: "Documentation Lifecycle"

## Notes

### Example Compression

**Before Compression**:
- User reads 4-phase CIP with 15 pages of implementation details
- Scattered across CIP, 4 backlog tasks, 50+ commits
- Takes 30 minutes to understand what was built

**After Compression**:
- README: "VibeSafe now supports Cursor, Copilot, Claude, and Codex"
- Sphinx docs: Installation guide with `VIBESAFE_PLATFORM` examples
- Architecture doc: "Platform-agnostic prompts in `templates/prompts/`"
- Takes 5 minutes to understand current state

### Compression is NOT

- ❌ Deleting CIPs (they remain for historical reference)
- ❌ Rewriting CIPs (they stay as-is, documenting the journey)
- ❌ Creating duplicate documentation (extract essence, don't copy)
- ❌ Required before CIP closure (recommended after)

### Compression IS

- ✅ Extracting essential knowledge from development artifacts
- ✅ Creating accessible documentation for future users
- ✅ Validating that implementation matches design intent
- ✅ Closing the feedback loop: WHY→WHAT→HOW→DO→DOCUMENT→WHY

