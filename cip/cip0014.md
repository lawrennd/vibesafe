---
id: "0014"
title: "Traceability Analysis and Reporting in whats-next"
author: "Neil Lawrence"
created: "2026-01-09"
last_updated: "2026-01-09"
status: Proposed
related_requirements: ["0006"]
related_cips: []
tags: ["validation", "traceability", "whats-next", "requirements"]
compressed: false
---

# CIP-0014: Traceability Analysis and Reporting in whats-next

## Status

- [x] Proposed ‚Üí Initial documentation complete
- [ ] Accepted ‚Üí Plan reviewed and approved
- [ ] In Progress ‚Üí Implementation has started
- [ ] Implemented ‚Üí Code changes complete
- [ ] Closed ‚Üí Implementation reviewed and merged

## Summary

Enhance the `whats-next` script to provide comprehensive traceability analysis across the VibeSafe hierarchy (Tenets ‚Üí Requirements ‚Üí CIPs ‚Üí Backlog). This implements the remaining acceptance criteria from REQ-0006 by scanning requirements files, building relationship graphs, detecting gaps, and reporting actionable insights about project workflow state.

**Implements:** REQ-0006 (Automated Process Conformance Validation) - specifically cross-reference validation, status consistency checks, and traceability reporting.

## Motivation

Currently, `whats-next` scans CIPs and backlog items but **doesn't track requirements** or analyze relationships between components. This creates several problems:

1. **Orphaned Requirements**: Requirements in "Ready" status with no CIPs implementing them
2. **Orphaned CIPs**: CIPs that don't reference any requirement (what WHAT are they solving?)
3. **Orphaned Backlog**: Tasks that don't reference a CIP (what HOW are they executing?)
4. **Status Drift**: Requirements marked "Implemented" but no CIP is actually "Closed"
5. **Missing Visibility**: No way to see "What requirements are waiting for implementation?"

**Example of the problem:**
```bash
# Current output (doesn't show this)
./whats-next
# Missing: "REQ-0006 is Ready but has no CIPs implementing it"
# Missing: "CIP-0014 doesn't reference any requirement"
# Missing: "5 backlog items don't reference a CIP"
```

This CIP implements the **traceability view** that shows workflow health and suggests next actions based on the VibeSafe hierarchy (WHY ‚Üí WHAT ‚Üí HOW ‚Üí DO).

## Detailed Description

### Architecture: Traceability Graph

Build an in-memory graph of relationships:

```
Tenets (WHY)
   ‚Üì (informs)
Requirements (WHAT)
   ‚Üì (guides - via CIP.related_requirements)
CIPs (HOW)
   ‚Üì (breaks into - via Backlog.related_cips)
Backlog (DO)
```

### New Functions in whats_next.py

#### 1. `scan_requirements(root_dir)` - Scan Requirements Files

Similar to `scan_cips()` and `scan_backlog()`, scan `requirements/` directory:

```python
def scan_requirements(root_dir='.'):
    """
    Scan requirements directory and extract metadata.
    
    Returns:
        {
            'total': int,
            'by_status': {
                'proposed': [req_info, ...],
                'ready': [req_info, ...],
                'in_progress': [req_info, ...],
                'implemented': [req_info, ...],
                'validated': [req_info, ...],
            },
            'by_priority': {
                'high': [req_info, ...],
                'medium': [req_info, ...],
                'low': [req_info, ...]
            },
            'all': [req_info, ...]  # All requirements with full metadata
        }
    
    Where req_info:
        {
            'id': '0006',
            'title': 'Automated Process Conformance Validation',
            'status': 'Ready',
            'priority': 'High',
            'file': 'requirements/req0006_...md',
            'related_tenets': ['validation-led-development'],
            'tags': ['validation', 'quality']
        }
    """
```

#### 2. `build_traceability_graph()` - Build Relationship Map

```python
def build_traceability_graph(requirements_info, cips_info, backlog_info):
    """
    Build traceability graph from component metadata.
    
    Returns:
        {
            'requirements_to_cips': {
                'req_id': [cip_id1, cip_id2, ...],
                ...
            },
            'cips_to_requirements': {
                'cip_id': [req_id1, req_id2, ...],
                ...
            },
            'cips_to_backlog': {
                'cip_id': [backlog_id1, backlog_id2, ...],
                ...
            },
            'backlog_to_cips': {
                'backlog_id': [cip_id1, ...],
                ...
            }
        }
    """
```

#### 3. `detect_traceability_gaps()` - Find Issues

```python
def detect_traceability_gaps(requirements_info, cips_info, backlog_info, graph):
    """
    Detect traceability issues and inconsistencies.
    
    Returns:
        {
            'requirements_without_cips': [req_info, ...],
            'cips_without_requirements': [cip_info, ...],
            'backlog_without_cips': [backlog_info, ...],
            'status_inconsistencies': [
                {
                    'type': 'requirement_implemented_but_no_closed_cip',
                    'requirement': req_info,
                    'related_cips': [cip_info, ...]
                },
                ...
            ]
        }
    """
```

#### 4. `generate_traceability_prompts()` - Actionable Suggestions

```python
def generate_traceability_prompts(gaps, requirements_info, cips_info):
    """
    Generate actionable prompts based on traceability gaps.
    
    Returns list of prompts like:
        [
            "REQ-0006 (Ready) has no CIPs ‚Üí Create CIP to implement this requirement",
            "CIP-0014 doesn't reference requirements ‚Üí Should this solve a specific WHAT?",
            "5 backlog items don't reference a CIP ‚Üí Link to CIPs or create CIPs first",
            "REQ-0005 status=Implemented but CIP-000X is only In Progress ‚Üí Update statuses"
        ]
    """
```

### Integration Points

#### Display in `main()` Output

Add new section after Requirements/CIPs/Backlog:

```python
# In main():
requirements_info = scan_requirements(root_dir)

# Print requirements summary (similar to CIPs/Backlog)
print(f"{Colors.BOLD}Requirements:{Colors.ENDC}")
print(f"  Total: {requirements_info['total']}")
# ... show by status ...

# Build traceability graph
graph = build_traceability_graph(requirements_info, cips_info, backlog_info)
gaps = detect_traceability_gaps(requirements_info, cips_info, backlog_info, graph)

# Display traceability analysis
if not args.quiet:
    print_section("Traceability Analysis")
    display_traceability_report(gaps, requirements_info, cips_info, backlog_info)
```

#### Add to `generate_next_steps()`

Integrate traceability prompts into existing next steps logic:

```python
def generate_next_steps(..., requirements_info, graph, gaps):
    steps = []
    
    # Existing logic for CIPs, backlog, compression...
    
    # Add traceability prompts
    traceability_prompts = generate_traceability_prompts(gaps, requirements_info, cips_info)
    steps.extend(traceability_prompts)
    
    # Prioritize by workflow state
    # e.g., "Ready requirement without CIP" is higher priority than other prompts
    
    return steps
```

### Command Line Flags

Add new flags for focused views:

```bash
./whats-next --traceability       # Show only traceability analysis
./whats-next --requirements-only  # Show only requirements (already exists)
./whats-next --gaps-only         # Show only gaps/issues
```

### Example Output

```bash
./whats-next

üìã Requirements:
  Total: 15
  Ready: 3
    - REQ-0006: Automated Process Conformance Validation
    - REQ-0009: Documentation Quality Standards
    - REQ-000F: Documentation Structure Specification
  In Progress: 2
  Implemented: 8
  Validated: 2

üìä Traceability Analysis:

‚ö†Ô∏è  Requirements without CIPs (3):
  - REQ-0006 (Ready, High): Automated Process Conformance Validation
    ‚Üí Status: Ready for implementation
    ‚Üí Suggest: Create CIP-00XX to define HOW to implement this
  
  - REQ-0009 (Ready, Medium): Documentation Quality Standards
    ‚Üí Suggest: Create CIP or mark as Deferred if not prioritized

‚úÖ All CIPs reference requirements

‚ö†Ô∏è  Backlog items without CIP reference (2):
  - 2026-01-08_orphaned-task.md (In Progress)
    ‚Üí Warning: What HOW does this implement?
    ‚Üí Suggest: Add related_cips field or create CIP first

‚ö†Ô∏è  Status Inconsistencies (1):
  - REQ-0005 status=Implemented but related CIPs not Closed
    ‚Üí CIP-000A: In Progress
    ‚Üí Suggest: Update REQ-0005 status to "In Progress" or close CIP-000A

‚ú® Suggested Next Steps:
1. Create CIP for REQ-0006 (Ready, High priority requirement)
2. Review 2 backlog items without CIP references
3. Resolve status inconsistency for REQ-0005
4. Continue work on in-progress backlog item: ...
```

### WHAT vs HOW Heuristics (REQ-0006 Feature)

Add lightweight heuristics to warn if requirements describe HOW instead of WHAT:

```python
def check_what_vs_how(requirement_text, requirement_id):
    """
    Check if requirement appears to describe HOW instead of WHAT.
    
    Heuristic patterns (NOT errors, just warnings):
    - Contains: "Create", "Implement", "Add", "Build", "Use X library"
    - Technical implementation details
    - Specific tool/technology names
    
    Returns:
        warnings: [
            "REQ-0006 contains 'Implement X' - does this describe HOW not WHAT?",
            ...
        ]
    """
```

Display in traceability analysis:

```bash
‚ö†Ô∏è  Requirements possibly describing HOW:
  - REQ-XXXX contains "Implement using PyYAML"
    ‚Üí Consider: Is this WHAT (outcome) or HOW (implementation)?
    ‚Üí Guidance: Requirements should describe desired state, not method
```

## Implementation Plan

### Phase 1: Requirements Scanning
- [ ] Implement `scan_requirements()` function
- [ ] Extract metadata from `requirements/req*.md` files
- [ ] Add requirements summary to `main()` output
- [ ] Test: Verify all requirements are detected and categorized

### Phase 2: Traceability Graph
- [ ] Implement `build_traceability_graph()` function
- [ ] Parse `related_requirements` from CIPs
- [ ] Parse `related_cips` from backlog items
- [ ] Parse `related_tenets` from requirements
- [ ] Test: Verify graph accurately reflects relationships

### Phase 3: Gap Detection
- [ ] Implement `detect_traceability_gaps()` function
- [ ] Detect requirements without CIPs
- [ ] Detect CIPs without requirements
- [ ] Detect backlog without CIP references
- [ ] Detect status inconsistencies
- [ ] Test: Verify all gap types are detected

### Phase 4: Reporting
- [ ] Implement `display_traceability_report()` function
- [ ] Format output with colors and clear sections
- [ ] Implement `generate_traceability_prompts()` function
- [ ] Integrate with `generate_next_steps()`
- [ ] Test: Verify output is clear and actionable

### Phase 5: WHAT vs HOW Heuristics
- [ ] Implement `check_what_vs_how()` function
- [ ] Define heuristic patterns for detecting HOW
- [ ] Add warnings to traceability report
- [ ] Test: Verify heuristics catch common patterns

### Phase 6: Command Line Flags
- [ ] Add `--traceability` flag
- [ ] Add `--gaps-only` flag
- [ ] Update `--requirements-only` to show detailed info
- [ ] Update help text and documentation
- [ ] Test: Verify all flags work as expected

### Phase 7: Documentation & Compression
- [ ] Update `docs/source/whats_next_script.md`
- [ ] Add examples to documentation
- [ ] Sync to `templates/scripts/whats_next.py`
- [ ] Update compression checklist if needed

## Backward Compatibility

‚úÖ **Fully backward compatible:**
- Existing output remains unchanged (unless `--traceability` flag used)
- New sections appear after existing CIPs/Backlog sections
- All existing command line flags continue to work
- Performance impact minimal (requirements scanning is fast)

**Graceful degradation:**
- If no requirements files exist, skip requirements scanning
- If requirements have no `related_tenets`, skip that validation
- If CIPs have no `related_requirements`, report as gap (not error)

## Testing Strategy

### Unit Tests (tests/test_whats_next.py)

Add test classes:
- `TestRequirementsScanning` - Test `scan_requirements()`
- `TestTraceabilityGraph` - Test `build_traceability_graph()`
- `TestGapDetection` - Test `detect_traceability_gaps()`
- `TestPromptGeneration` - Test `generate_traceability_prompts()`
- `TestWhatVsHow` - Test WHAT vs HOW heuristics

### Integration Tests

Test end-to-end scenarios:
- Repository with complete traceability (no gaps)
- Repository with requirements but no CIPs
- Repository with CIPs but no requirement references
- Repository with status inconsistencies

### Manual Testing

```bash
# Test on VibeSafe itself (dogfooding)
./whats-next --traceability

# Test filtering
./whats-next --requirements-only
./whats-next --gaps-only

# Test with missing directories
mkdir test-repo && cd test-repo
# Create requirements but no CIPs
./whats-next  # Should report requirements without CIPs
```

## Related Requirements

This CIP implements **REQ-0006: Automated Process Conformance Validation**, specifically:

- ‚úÖ "Script validates cross-references (requirements ‚Üî CIPs ‚Üî backlog)"
- ‚úÖ "Script checks status consistency across related components"
- ‚úÖ "Script warns if requirements appear to describe implementation (HOW not WHAT)"

## Implementation Status

- [ ] Phase 1: Requirements Scanning
- [ ] Phase 2: Traceability Graph
- [ ] Phase 3: Gap Detection
- [ ] Phase 4: Reporting
- [ ] Phase 5: WHAT vs HOW Heuristics
- [ ] Phase 6: Command Line Flags
- [ ] Phase 7: Documentation & Compression

## References

- [REQ-0006](../requirements/req0006_process-conformance-validation.md) - Automated Process Conformance Validation
- [whats-next script documentation](../docs/source/whats_next_script.md)
- Existing `scan_cips()` and `scan_backlog()` functions in `scripts/whats_next.py`
- VibeSafe hierarchy: Tenets ‚Üí Requirements ‚Üí CIPs ‚Üí Backlog

## Notes

### Why This Matters

Traceability is critical for:
1. **Workflow visibility**: See what's waiting for implementation
2. **Quality assurance**: Ensure every CIP solves a documented WHAT
3. **Project planning**: Identify bottlenecks (many Ready requirements, few CIPs)
4. **Status accuracy**: Keep requirement/CIP/backlog statuses in sync

### Design Decisions

**Q: Why scan requirements in `whats-next` instead of validation script?**  
A: `whats-next` is about **workflow guidance** ("What should I work on?"), while validation is about **conformance** ("Is structure correct?"). Traceability analysis guides workflow decisions.

**Q: Why heuristics for WHAT vs HOW instead of strict rules?**  
A: Language is nuanced. Heuristics warn but don't block, respecting user judgment. Aligns with "User Autonomy" tenet.

**Q: Performance impact of scanning requirements?**  
A: Minimal. Requirements directory is small (~15 files), scanning adds <100ms. Graph building is O(n) where n = total components.

