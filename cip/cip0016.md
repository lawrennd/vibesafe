---
id: "0016"
title: "CoE (Cause of Error) Process for Governance and Traceability"
status: "Proposed"
created: "2026-01-10"
last_updated: "2026-01-10"
author: "Neil Lawrence"
compressed: false
related_requirements: ["0010", "0006", "000E"]
related_cips: ["0015", "0011"]
tags:
  - cip
  - governance
  - process
  - traceability
  - validation
---

# CIP-0016: CoE (Cause of Error) Process for Governance and Traceability

## Status

- [x] Proposed - Initial idea documented
- [ ] Accepted - Approved, ready to start work
- [ ] In Progress - Actively being implemented
- [ ] Implemented - Work complete, awaiting verification
- [ ] Closed - Verified and complete
- [ ] Rejected - Will not be implemented (add reason, use superseded_by if replaced)
- [ ] Deferred - Postponed (use blocked_by field to indicate blocker)

## Summary

Define a lightweight **Cause of Error** process for governance/traceability incidents: a repeatable way to *analyse why an error occurred*, classify its severity, and produce actionable follow-ups (mitigations, tripwires, documentation fixes) without bundling those fixes into the CoE itself.

This CIP is prompted by the “own goal” documented in **CIP-0015**: implementing governance behaviour before documenting the HOW/DO layer.

## Motivation

Human authorship and accountability implies not just “a name in metadata”, but a repeatable way to **understand when we get it wrong**:
- identify the *cause(s)* of the error (not just the symptoms),
- classify severity and scope,
- and produce the right-sized remediation and prevention actions.

The key design constraint is **lightweightness**: minor internal governance mistakes should be easy to correct, while customer/deployed impact should trigger a stronger response.

## Detailed Description

### What counts as a governance/traceability CoE incident

CoE analysis applies when we discover any of:
- a policy encoded in code without the expected planning artifacts (missing requirement/CIP/backlog),
- a traceability break (e.g. downward links where forbidden, missing links where required),
- an enforcement/validator change that wasn’t documented,
- template/runtime drift that could affect users on install/update,
- any customer/deployment-impacting workflow regression introduced by governance tooling.

### Scope: what kinds of changes are “governance sensitive”

Changes touching any of:
- `scripts/validate_vibesafe_structure.py` (and template copies)
- `scripts/whats_next.py` (and template copies)
- install scripts / deployment of system files
- templates that define user-facing process (CIP/backlog/requirements templates, cursor rules)
- rule changes that affect bottom-up linking / exception paths / enforcement semantics

### Severity classification (lightweight by default)

Classify each incident as one of:
- **Class 0 (Minor / internal-only)**: process slip with no user-facing impact (e.g. missing CIP for a validator rule change).
  - Typical outputs: short retrospective CIP/backlog note; optional tripwire warning.
- **Class 1 (Workflow-impacting)**: impacts contributors/maintainers (e.g. validation suddenly blocks common edits; install/update drift).
  - Typical outputs: retrospective CIP + backlog task; tests; possible notes.
- **Class 2+ (External-impacting)**: anything that affects downstream users/projects, deployed behaviour, customer outcomes, or legal/regulatory exposure.
  - Typical outputs: retrospective CIP + explicit remediation plan (backlog tasks), validation hook(s), and a defined communication step.

**Note (mapping to “Sev” scales)**: We intentionally stop at “2+” for now. More severe sub-classes (e.g. security incidents, legal/regulatory violations) may exist, but we defer documenting a full taxonomy until we have real cases and a clear need.

Many orgs use **inverse-numbered Sev scales** where **Sev 1 is most severe** and higher numbers are less severe. Our **Class scale increases with severity** (Class 0 < Class 1 < Class 2+), but the boundary between Class 1 and Class 2+ can be fuzzy: workflow/documentation breakage can become external if it affects published docs, installs, or downstream users.

So treat any Sev mapping as *directional only*, and classify primarily by **blast radius**:
- **Class 0**: internal-only, easily reversible, low blast radius (often “lower Sev”, e.g. Sev 4–5).
- **Class 1**: maintainer/contributor workflow impact *that is not yet externally impactful* (often still “lower Sev”, e.g. Sev 4–3).
- **Class 2+**: any external impact (downstream users/projects, deployed behaviour, customer outcomes, legal/regulatory exposure) (often “worse Sev”, e.g. Sev 2–1).

**Why the Class scale starts at 0 (and is “unbounded”)**: Class is meant to be a **blast-radius index**. Class 0 is the baseline “internal-only” case. Class 1 is a larger radius (maintainers/contributors). Class 2+ is external. We write “2+” because we’re intentionally not defining the rest of the ladder yet—there may be larger radii in future (e.g. broad downstream breakage, safety/legal exposure, ecosystem-wide impact). This makes the Class scale naturally **unbounded**.

**Why the Class numbering direction is “reversed” vs Sev scales**: many Sev systems use **Sev 1 = worst** (numbers go *down* as severity goes *up*) because they’re optimized for paging/operations conventions. Our Class numbering goes *up* with blast radius because it’s an **analysis/traceability taxonomy** rather than an on-call paging taxonomy.

**Rule of thumb**: when uncertain, **classify upward** (prefer a false positive escalation over missing external impact).

### CoE workflow (cause-of-error analysis, post-incident)

- **Single-threaded owner**: one named human owns the correction and follow-through.
- **CoE write-up**: record (a) what happened, (b) impact, (c) cause(s), (d) contributing factors, (e) proposed mitigations/follow-ups.
- **Outputs, not implementation**: CoE produces backlog tasks / CIPs / changes to validation tripwires; those are implemented separately.

### Preventative tripwires (optional, not heavy gates)

We still want early detection, but not heavyweight “before it lands” process:
- git-aware warnings for governance drift (implementation changed without CIP/backlog updates),
- traceability gap warnings (tenets/requirements + implementation changed without CIP/backlog updates),
- template/runtime drift enforcement (already present).

### Validation hooks (preventing repeats)

Add (or extend) automated checks to detect:
- **Implementation changed** without any **CIP/backlog** change (governance drift)
- **Tenet/requirement changed** with implementation change but no CIP/backlog update (traceability gap)
- Templates drift from runtime files (already enforced)

Design principle: these checks should be warnings by default and become strict in CI/`--strict` mode.

### Checklist (initial draft)

- [ ] What severity class is this CoE?
- [ ] Who is the single-threaded owner?
- [ ] What is the impact (internal/workflow/user/deployed)?
- [ ] What was the proximate failure (what broke)?
- [ ] What was the cause (why did it happen)?
- [ ] What were contributing factors (process/tooling/assumptions)?
- [ ] What traceability artifact(s) were missing or incorrect (tenet/requirement/CIP/backlog)?
- [ ] What follow-ups are required (mitigation tasks, documentation, tripwires)?

## Implementation Plan

1. Agree severity classes and the minimal CoE write-up template.
2. Decide where “tripwire” warnings live (validator / `whats-next` / optional CI strict mode).
3. (Deferred) Implement any additional metadata fields needed to record CoE ownership/classification.

## Backward Compatibility

Must avoid turning normal work into heavy ceremony:
- default to warnings (opt-in strictness),
- keep the review checklist short,
- and scope it to governance-sensitive file sets.

## Testing Strategy

- Unit tests for any new validator rule(s).
- Integration check: run validator on repo + ensure expected warnings appear for deliberate “bad” examples.

## References

- CIP-0015: `cip/cip0015.md`
- Validator: `scripts/validate_vibesafe_structure.py`
- Project summarizer: `scripts/whats_next.py`


